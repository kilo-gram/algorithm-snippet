{
	// writer : kilogram
	// creating time : 2025-08-06
	
	"PS": {
		"prefix": "ps",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;\n",
			"typedef long long ll;\n",
			"int main()",
			"{",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(nullptr);\n",
			"\t$0",
			"\treturn 0;",
			"}",
		],
		"description": "Log output to console"
	},

	"DSU": {
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"\tvector<int> par, rnk, sz;",
			"\tint c;",
			"\tDSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {",
			"\t\tfor (int i = 1; i <= n; ++i) par[i] = i;",
			"\t}",
			"\tint find(int i) {",
			"\t\treturn (par[i] == i ? i : (par[i] = find(par[i])));",
			"\t}",
			"\tbool same(int i, int j) {",
			"\t\treturn find(i) == find(j);",
			"\t}",
			"\tint get_size(int i) {",
			"\t\treturn sz[find(i)];",
			"\t}",
			"\tint count() {",
			"\t\treturn c;",
			"\t}",
			"\tint unite(int i, int j) {",
			"\t\tif ((i = find(i)) == (j = find(j))) return -1;",
			"\t\telse --c;",
			"\t\tif (rnk[i] > rnk[j]) swap(i, j);",
			"\t\tpar[i] = j;",
			"\t\tsz[j] += sz[i];",
			"\t\tif (rnk[i] == rnk[j]) rnk[j]++;",
			"\t\treturn j;",
			"\t}",
			"};",
		],
		"description": "Disjoint Set union"
	},

	"Fenwick tree (BIT)": {
		"prefix": "fenwick",
		"body": [
			"template <class T>",
			"struct fenwick { //1-indexed",
			"\tint n; vector<T> t;",
			"\tfenwick() {}",
			"\tfenwick(int _n) {",
			"\t\tn = _n; t.assign(n + 1, 0);",
			"\t}",
			"\tT query(int i) {",
			"\t\tT ans = 0;",
			"\t\tfor (; i >= 1; i -= (i & -i)) ans += t[i];",
			"\t\treturn ans;",
			"\t}",
			"\tvoid upd(int i, T val) {",
			"\t\tif (i <= 0) return;",
			"\t\tfor (; i <= n; i += (i & -i)) t[i] += val;",
			"\t}",
			"\tvoid upd(int l, int r, T val) {",
			"\t\tupd(l, val);",
			"\t\tupd(r + 1, -val);",
			"\t}",
			"\tT query(int l, int r) {",
			"\t\treturn query(r) - query(l - 1);",
			"\t}",
			"};",
		],
		"description": "Fenwick tree = Binary indexed tree"
	},

	"Segment tree": {
		"prefix": "seg",
		"body": [
			"const int N = 3e5 + 9;",
			"",
			"int a[N];",
			"struct ST {",
			"\tint t[4 * N];",
			"\tstatic const int inf = 1e9;",
			"\tST() {",
			"\t\tmemset(t, 0, sizeof t);",
			"\t}",
			"\tvoid build(int n, int b, int e) {",
			"\t\tif (b == e) {",
			"\t\t\tt[n] = a[b];",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tbuild(l, b, mid);",
			"\t\tbuild(r, mid + 1, e);",
			"\t\tt[n] = max(t[l], t[r]);",
			"\t}",
			"\tvoid upd(int n, int b, int e, int i, int x) {",
			"\t\tif (b > i || e < i) return;",
			"\t\tif (b == e && b == i) {",
			"\t\t\tt[n] = x;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tupd(l, b, mid, i, x);",
			"\t\tupd(r, mid + 1, e, i, x);",
			"\t\tt[n] = max(t[l], t[r]);",
			"\t}",
			"\tint query(int n, int b, int e, int i, int j) {",
			"\t\tif (b > j || e < i) return -inf;",
			"\t\tif (b >= i && e <= j) return t[n];",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tint L = query(l, b, mid, i, j);",
			"\t\tint R = query(r, mid + 1, e, i, j);",
			"\t\treturn max(L, R);",
			"\t}",
			"}t;",
		],
		"description": "Segment tree"
	},
	
	"Digit DP": {
		"prefix": "digit_dp",
		"body": [
			"vector<int> num;",
			"int a, b, d, k;",
			"int DP[12][12][2];",
			"",
			"int find(int pos, int cnt, int f) {",
			"\tif (cnt > k) return 0;",
			"",
			"\tif (pos == num.size()) {",
			"\t\tif (cnt == k) return 1;",
			"\t\treturn 0;",
			"\t}",
			"",
			"\tif (DP[pos][cnt][f] != -1) return DP[pos][cnt][f];",
			"\tint res = 0;",
			"",
			"\tint LMT;",
			"",
			"\t// f ? (greater than b) : (already smaller than b)",
			"\tif (f == 0) LMT = num[pos];",
			"\telse LMT = 9;",
			"",
			"\tfor (int dgt = 0; dgt <= LMT; dgt++) {",
			"\t\tint nf = f;",
			"\t\tint ncnt = cnt;",
			"\t\tif (f == 0 && dgt < LMT) nf = 1; /// The number is getting smaller at this position",
			"\t\tif (dgt == d) ncnt++;",
			"\t\tif (ncnt <= k) res += find(pos + 1, ncnt, nf);",
			"\t}",
			"",
			"\treturn DP[pos][cnt][f] = res;",
			"}",
			"",
			"int digitcount(int b) {",
			"\tnum.clear();",
			"\twhile(b > 0) {",
			"\t\tnum.push_back(b % 10);",
			"\t\tb /= 10;",
			"\t}",
			"\treverse(num.begin(), num.end());",
			"",
			"\tmemset(DP, -1, sizeof(DP));",
			"\tint res = find(0, 0, 0);",
			"\treturn res;",
			"}",
		],
		"description": "Digit DP"
	},

	"topological sorting": {
		"prefix": "topological_sorting",
		"body": [
			"const int N = 1e5 + 9;",
			"vector<int> g[N];",
			"bool vi[N];",
			"vector<int> ord;",
			"void dfs(int u) {",
			"\tvi[u] = true;",
			"\tfor (auto v: g[u]) {",
			"\t\tif (!vi[v]) {",
			"\t\t\tdfs(v);",
			"\t\t}",
			"\t}",
			"\tord.push_back(u);",
			"}",
		],
		"description": "topological sorting"
	},

	"DFS_tree": {
		"prefix": "dfs_tree",
		"body": [
			"const int N = 3e5 + 5;",
			"",
			"int bridge = 0;",
			"vector<int> adj[N];",
			"int lv[N];",
			"int dp[N];",
			"",
			"void dfs (int v) {",
			"\tdp[v] = 0;",
			"\tfor (int u : adj[v]) {",
			"\t\tif (lv[u] == 0) {",
			"\t\t\tlv[u] = lv[v] + 1;",
			"\t\t\tdfs(u);",
			"\t\t\tdp[v] += dp[u];",
			"\t\t} else if (lv[u] < lv[v]) {",
			"\t\t\tdp[v]++;",
			"\t\t} else if (lv[u] > lv[v]) {",
			"\t\t\tdp[v]--;",
			"\t\t}",
			"\t}",
			"",
			"\tdp[v]--;",
			"",
			"\tif (lv[v] > 1 && dp[v] == 0) {",
			"\t\tbridge++;",
			"\t}",
			"}",
		],
		"description": "classical dfs tree implementation"
	},

	"dicycle detection": {
		"prefix": "dicycle detection",
		"body": [
			"int n;",
			"vector<vector<int>> adj;",
			"vector<char> color;",
			"vector<int> parent;",
			"int cycle_start, cycle_end;",
			"",
			"bool dfs(int v) {",
			"\tcolor[v] = 1;",
			"\tfor (int u : adj[v]) {",
			"\t\tif (color[u] == 0) {",
			"\t\t\tparent[u] = v;",
			"\t\t\tif (dfs(u))",
			"\t\t\t\treturn true;",
			"\t\t} else if (color[u] == 1) {",
			"\t\t\tcycle_end = v;",
			"\t\t\tcycle_start = u;",
			"\t\t\treturn true;",
			"\t\t}",
			"\t}",
			"\tcolor[v] = 2;",
			"\treturn false;",
			"}",
			"",
			"void find_cycle() {",
			"\tcolor.assign(n, 0);",
			"\tparent.assign(n, -1);",
			"\tcycle_start = -1;",
			"",
			"\tfor (int v = 0; v < n; v++) {",
			"\t\tif (color[v] == 0 && dfs(v))",
			"\t\t\tbreak;",
			"\t}",
			"",
			"\tif (cycle_start == -1) {",
			"\t\t//this graph is acyclic.",
			"\t} else {",
			"\t\tvector<int> cycle;",
			"\t\tcycle.push_back(cycle_start);",
			"\t\tfor (int v = cycle_end; v != cycle_start; v = parent[v])",
			"\t\t\tcycle.push_back(v);",
			"\t\tcycle.push_back(cycle_start);",
			"\t\treverse(cycle.begin(), cycle.end());",
			"",
			"\t\t//this graph isn't acyclic.",
			"\t\tfor (int v : cycle) {",
			"\t\t\t//any cycle",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "cycle detection for directed graph"
	},

	"undicycle detection": {
		"prefix": "undicycle detection",
		"body": [
			"int n;",
			"vector<vector<int>> adj;",
			"vector<bool> visited;",
			"vector<int> parent;",
			"int cycle_start, cycle_end;",
			"",
			"bool dfs(int v, int par) { // passing vertex and its parent vertex",
			"\tvisited[v] = true;",
			"\tfor (int u : adj[v]) {",
			"\t\tif(u == par) continue; // skipping edge to parent vertex",
			"\t\tif (visited[u]) {",
			"\t\t\tcycle_end = v;",
			"\t\t\tcycle_start = u;",
			"\t\t\treturn true;",
			"\t\t}",
			"\t\tparent[u] = v;",
			"\t\tif (dfs(u, parent[u]))",
			"\t\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}",
			"",
			"void find_cycle() {",
			"\tvisited.assign(n, false);",
			"\tparent.assign(n, -1);",
			"\tcycle_start = -1;",
			"",
			"\tfor (int v = 0; v < n; v++) {",
			"\t\tif (!visited[v] && dfs(v, parent[v]))",
			"\t\t\tbreak;",
			"\t}",
			"",
			"\tif (cycle_start == -1) {",
			"\t\t//this graph is acyclic.",
			"\t} else {",
			"\t\tvector<int> cycle;",
			"\t\tcycle.push_back(cycle_start);",
			"\t\tfor (int v = cycle_end; v != cycle_start; v = parent[v])",
			"\t\t\tcycle.push_back(v);",
			"\t\tcycle.push_back(cycle_start);",
			"",
			"\t\t//this graph isn't acyclic.",
			"\t\tfor (int v : cycle) {",
			"\t\t\t//any cycle",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "cycle detection for directed graph"
	},

}