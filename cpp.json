{
	// writer : kilogram
	// creating time : 2025-08-06
	
	"PS": {
		"prefix": "ps",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;\n",
			"typedef long long ll;\n",
			"int main()",
			"{",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(nullptr);\n",
			"\t$0",
			"\treturn 0;",
			"}",
		],
		"description": "Log output to console"
	},
	"DSU": {
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"\tvector<int> par, rnk, sz;",
			"\tint c;",
			"\tDSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {",
			"\t\tfor (int i = 1; i <= n; ++i) par[i] = i;",
			"\t}",
			"\tint find(int i) {",
			"\t\treturn (par[i] == i ? i : (par[i] = find(par[i])));",
			"\t}",
			"\tbool same(int i, int j) {",
			"\t\treturn find(i) == find(j);",
			"\t}",
			"\tint get_size(int i) {",
			"\t\treturn sz[find(i)];",
			"\t}",
			"\tint count() {",
			"\t\treturn c;",
			"\t}",
			"\tint unite(int i, int j) {",
			"\t\tif ((i = find(i)) == (j = find(j))) return -1;",
			"\t\telse --c;",
			"\t\tif (rnk[i] > rnk[j]) swap(i, j);",
			"\t\tpar[i] = j;",
			"\t\tsz[j] += sz[i];",
			"\t\tif (rnk[i] == rnk[j]) rnk[j]++;",
			"\t\treturn j;",
			"\t}",
			"};",
		],
		"description": "Disjoint Set union"
	},
	"Fenwick tree (BIT)": {
		"prefix": "fenwick",
		"body": [
			"template <class T>",
			"struct fenwick { //1-indexed",
			"\tint n; vector<T> t;",
			"\tfenwick() {}",
			"\tfenwick(int _n) {",
			"\t\tn = _n; t.assign(n + 1, 0);",
			"\t}",
			"\tT query(int i) {",
			"\t\tT ans = 0;",
			"\t\tfor (; i >= 1; i -= (i & -i)) ans += t[i];",
			"\t\treturn ans;",
			"\t}",
			"\tvoid upd(int i, T val) {",
			"\t\tif (i <= 0) return;",
			"\t\tfor (; i <= n; i += (i & -i)) t[i] += val;",
			"\t}",
			"\tvoid upd(int l, int r, T val) {",
			"\t\tupd(l, val);",
			"\t\tupd(r + 1, -val);",
			"\t}",
			"\tT query(int l, int r) {",
			"\t\treturn query(r) - query(l - 1);",
			"\t}",
			"};",
		],
		"description": "Fenwick tree = Binary indexed tree"
	},
	"Segment tree": {
		"prefix": "seg",
		"body": [
			"const int N = 3e5 + 9;",
			"",
			"int a[N];",
			"struct ST {",
			"\tint t[4 * N];",
			"\tstatic const int inf = 1e9;",
			"\tST() {",
			"\t\tmemset(t, 0, sizeof t);",
			"\t}",
			"\tvoid build(int n, int b, int e) {",
			"\t\tif (b == e) {",
			"\t\t\tt[n] = a[b];",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tbuild(l, b, mid);",
			"\t\tbuild(r, mid + 1, e);",
			"\t\tt[n] = max(t[l], t[r]);",
			"\t}",
			"\tvoid upd(int n, int b, int e, int i, int x) {",
			"\t\tif (b > i || e < i) return;",
			"\t\tif (b == e && b == i) {",
			"\t\t\tt[n] = x;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tupd(l, b, mid, i, x);",
			"\t\tupd(r, mid + 1, e, i, x);",
			"\t\tt[n] = max(t[l], t[r]);",
			"\t}",
			"\tint query(int n, int b, int e, int i, int j) {",
			"\t\tif (b > j || e < i) return -inf;",
			"\t\tif (b >= i && e <= j) return t[n];",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tint L = query(l, b, mid, i, j);",
			"\t\tint R = query(r, mid + 1, e, i, j);",
			"\t\treturn max(L, R);",
			"\t}",
			"}t;",
		],
		"description": "Segment tree"
	},
	"Digit DP": {
		"prefix": "digit dp",
		"body": [
			"vector<int> num;",
			"int a, b, d, k;",
			"int DP[12][12][2];",
			"",
			"int find(int pos, int cnt, int f) {",
			"\tif (cnt > k) return 0;",
			"",
			"\tif (pos == num.size()) {",
			"\t\tif (cnt == k) return 1;",
			"\t\treturn 0;",
			"\t}",
			"",
			"\tif (DP[pos][cnt][f] != -1) return DP[pos][cnt][f];",
			"\tint res = 0;",
			"",
			"\tint LMT;",
			"",
			"\t// f ? (greater than b) : (already smaller than b)",
			"\tif (f == 0) LMT = num[pos];",
			"\telse LMT = 9;",
			"",
			"\tfor (int dgt = 0; dgt <= LMT; dgt++) {",
			"\t\tint nf = f;",
			"\t\tint ncnt = cnt;",
			"\t\tif (f == 0 && dgt < LMT) nf = 1; /// The number is getting smaller at this position",
			"\t\tif (dgt == d) ncnt++;",
			"\t\tif (ncnt <= k) res += find(pos + 1, ncnt, nf);",
			"\t}",
			"",
			"\treturn DP[pos][cnt][f] = res;",
			"}",
			"",
			"int digitcount(int b) {",
			"\tnum.clear();",
			"\twhile(b > 0) {",
			"\t\tnum.push_back(b % 10);",
			"\t\tb /= 10;",
			"\t}",
			"\treverse(num.begin(), num.end());",
			"",
			"\tmemset(DP, -1, sizeof(DP));",
			"\tint res = find(0, 0, 0);",
			"\treturn res;",
			"}",
		],
		"description": "Digit DP"
	},
	"topological sorting": {
		"prefix": "topological sorting",
		"body": [
			"const int N = 1e5 + 9;",
			"vector<int> g[N];",
			"bool vi[N];",
			"vector<int> ord;",
			"void dfs(int u) {",
			"\tvi[u] = true;",
			"\tfor (auto v : g[u]) {",
			"\t\tif (!vi[v]) {",
			"\t\t\tdfs(v);",
			"\t\t}",
			"\t}",
			"\tord.push_back(u);",
			"}",
			"",
			"void find(int n) {",
			"\tfor (int i = 1; i <= n; i++) {",
			"\t\tif (!vi[i]) {",
			"\t\t\tdfs(i);",
			"\t\t}",
			"\t}",
			"\treverse(ord.begin(), ord.end());",
			"",
			"\t// check is feasible",
			"\tvector<int> pos(n + 1);",
			"\tfor (int i = 0; i < (int) ord.size(); i++) {",
			"\t\tpos[ord[i]] = i;",
			"\t}",
			"\tfor (int u = 1; u <= n; u++) {",
			"\t\tfor (auto v : g[u]) {",
			"\t\t\t// We need to consider self loops too!",
			"\t\t\tif (pos[u] >= pos[v]) { ",
			"\t\t\t\t//print impossible",
			"\t\t\t\treturn;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\t// print the order",
			"\tfor (auto u : ord) cout << u << ' ';",
			"}",
		],
		"description": "topological sorting"
	},
	"DFS_tree": {
		"prefix": "dfs tree",
		"body": [
			"const int N = 3e5 + 5;",
			"",
			"int bridge = 0;",
			"vector<int> adj[N];",
			"int lv[N];",
			"int dp[N];",
			"",
			"void dfs (int v) {",
			"\tdp[v] = 0;",
			"\tfor (int u : adj[v]) {",
			"\t\tif (lv[u] == 0) {",
			"\t\t\tlv[u] = lv[v] + 1;",
			"\t\t\tdfs(u);",
			"\t\t\tdp[v] += dp[u];",
			"\t\t} else if (lv[u] < lv[v]) {",
			"\t\t\tdp[v]++;",
			"\t\t} else if (lv[u] > lv[v]) {",
			"\t\t\tdp[v]--;",
			"\t\t}",
			"\t}",
			"",
			"\tdp[v]--;",
			"",
			"\tif (lv[v] > 1 && dp[v] == 0) {",
			"\t\tbridge++;",
			"\t}",
			"}",
		],
		"description": "classical dfs tree implementation"
	},
	"cycle detection": {
		"prefix": "cycle detection",
		"body": [
			"// It is possible both undigraph and digraph.",
			"const int N = 5e5 + 9;",
			"",
			"vector<pair<int, int>> g[N];",
			"int vis[N], par[N], e_id[N];",
			"vector<int> cycle; // simple cycle, contains edge ids",
			"",
			"bool dfs(int u) {",
			"\tif (!cycle.empty()) return 1;",
			"\tvis[u] = 1;",
			"\tfor (auto [v, id] : g[u]) {",
			"\t\tif (v != par[u]) {",
			"\t\t\tif (vis[v] == 0) {",
			"\t\t\t\tpar[v] = u;",
			"\t\t\t\te_id[v] = id;",
			"\t\t\t\tif (dfs(v)) return 1;",
			"\t\t\t}",
			"\t\t\telse if (vis[v] == 1) {",
			"\t\t\t\t// cycle here",
			"\t\t\t\tcycle.push_back(id);",
			"\t\t\t\tfor (int x = u; x != v; x = par[x]) {",
			"\t\t\t\t\tcycle.push_back(e_id[x]);",
			"\t\t\t\t}",
			"\t\t\t\treturn 1;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvis[u] = 2;",
			"\treturn 0;",
			"}",
			"void solve(int n, int m) {",
			"\tfor (int i = 1; i < m + 1; i++) {",
			"\t\tint u, v;",
			"\t\tcin >> u >> v;",
			"\t\tu++;",
			"\t\tv++;",
			"\t\tg[u].push_back({v, i});",
			"\t}",
			"\tfor (int u = 1; u < n + 1; u++) {",
			"\t\tif (vis[u] == 0 && dfs(u)) {",
			"\t\t\t// this graph is acyclic",
			"\t\t\tfor (auto x : cycle) {",
			"\t\t\t\t// any cycle",
			"\t\t\t}",
			"\t\t\treturn;",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "cycle detection"
	},
	"Binary Lifting and lowest common ancester": {
		"prefix": "lca",
		"body": [
			"const int N = 3e5 + 9, LG = 18;",
			"",
			"vector<int> g[N];",
			"int par[N][LG + 1], dep[N], sz[N];",
			"// don't forget to call dfs(1)",
			"void dfs(int u, int p = 0) {",
			"\tpar[u][0] = p;",
			"\tdep[u] = dep[p] + 1;",
			"\tsz[u] = 1;",
			"\tfor (int i = 1; i <= LG; i++) par[u][i] = par[par[u][i - 1]][i - 1];",
			"\tfor (auto v : g[u]) {",
			"\t\tif (v != p) {",
			"\t\t\tdfs(v, u);",
			"\t\t\tsz[u] += sz[v];",
			"\t\t}",
			"\t}",
			"}",
			"int lca(int u, int v) {",
			"\tif (dep[u] < dep[v]) swap(u, v);",
			"\tfor (int k = LG; k >= 0; k--) if (dep[par[u][k]] >= dep[v]) u = par[u][k];",
			"\tif (u == v) return u;",
			"\tfor (int k = LG; k >= 0; k--) if (par[u][k] != par[v][k]) u = par[u][k], v = par[v][k];",
			"\treturn par[u][0];",
			"}",
			"// 'kth'function is a Binary Lifting",
			"int kth(int u, int k) {",
			"\tassert(k >= 0);",
			"\tfor (int i = 0; i <= LG; i++) if (k & (1 << i)) u = par[u][i];",
			"\treturn u;",
			"}",
			"int dist(int u, int v) {",
			"\tint l = lca(u, v);",
			"\treturn dep[u] + dep[v] - (dep[l] << 1);",
			"}",
			"//kth node from u to v, 0th node is u",
			"int go(int u, int v, int k) {",
			"\tint l = lca(u, v);",
			"\tint d = dep[u] + dep[v] - (dep[l] << 1);",
			"\tassert(k <= d);",
			"\tif (dep[l] + k <= dep[u]) return kth(u, k);",
			"\tk -= dep[u] - dep[l];",
			"\treturn kth(v, dep[v] - dep[l] - k);",
			"}",
		],
		"description": "Binary Lifting and lowest common ancester"
	},
	"SCC": {
		"prefix": "scc",
		"body": [
			"const int N = 3e5 + 9;",
			"",
			"// given a directed graph return the minimum number of edges to be added so that the whole graph become an SCC",
			"// you need to restore original graph in g and reverse graph in r.",
			"bool vis[N];",
			"vector<int> g[N], r[N], G[N], vec; //G is the condensed graph",
			"void dfs1(int u) {",
			"\tvis[u] = 1;",
			"\tfor(auto v : g[u]) if (!vis[v]) dfs1(v);",
			"\tvec.push_back(u);",
			"}",
			"",
			"vector<int> comp;",
			"void dfs2(int u) {",
			"\tcomp.push_back(u);",
			"\tvis[u] = 1;",
			"\tfor(auto v : r[u]) if (!vis[v]) dfs2(v);",
			"}",
			"",
			"int idx[N], in[N], out[N];",
			"",
			"void find(int n) {",
			"\tfor(int i = 1; i <= n; i++) if(!vis[i]) dfs1(i);",
			"\treverse(vec.begin(), vec.end());",
			"\tmemset(vis, 0, sizeof(vis));",
			"\tint scc = 0;",
			"\tfor(auto u : vec) {",
			"\t\tif(!vis[u]) {",
			"\t\t\tcomp.clear();",
			"\t\t\tdfs2(u);",
			"\t\t\tscc++;",
			"\t\t\tfor(auto x : comp) idx[x] = scc;",
			"\t\t}",
			"\t}",
			"\tfor(int u = 1; u <= n; u++) {",
			"\t\tfor(auto v : g[u]) {",
			"\t\t\tif(idx[u] != idx[v]) {",
			"\t\t\t\tin[idx[v]]++, out[idx[u]]++;",
			"\t\t\t\tG[idx[u]].push_back(idx[v]);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tint needed_in = 0, needed_out = 0;",
			"\tfor(int i = 1; i <= scc; i++) {",
			"\t\tif(!in[i]) needed_in++;",
			"\t\tif(!out[i]) needed_out++;",
			"\t}",
			"\tint ans = max(needed_in, needed_out);",
			"\tif(scc == 1) ans = 0;",
			"\tcout << ans;",
			"}",
		],
		"description": "SCC"
	},
	"Articulation Bridges and Bridge Tree": {
		"prefix": "bridge tree",
		"body": [
			"// you should write TECC t(g) int main funtion after that you add edges in graph g.",
			"struct TECC { // 0 indexed",
			"\tint n, k;",
			"\tvector<vector<int>> g, t;",
			"\tvector<bool> used;",
			"\tvector<int> comp, ord, low;",
			"\tusing edge = pair<int, int>;",
			"\tvector<edge> br;",
			"\tvoid dfs(int x, int prv, int &c) {",
			"\t\tused[x] = 1; ord[x] = c++; low[x] = n;",
			"\t\tbool mul = 0;",
			"\t\tfor (auto y : g[x]) {",
			"\t\t\tif (used[y]) {",
			"\t\t\t\tif (y != prv || mul) low[x] = min(low[x], ord[y]);",
			"\t\t\t\telse mul = 1;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tdfs(y, x, c);",
			"\t\t\tlow[x] = min(low[x], low[y]);",
			"\t\t}",
			"\t}",
			"\tvoid dfs2(int x, int num) {",
			"\t\tcomp[x] = num;",
			"\t\tfor (auto y : g[x]) {",
			"\t\t\tif (comp[y] != -1) continue;",
			"\t\t\tif (ord[x] < low[y]) {",
			"\t\t\t\tbr.push_back({x, y});",
			"\t\t\t\tk++;",
			"\t\t\t\tdfs2(y, k);",
			"\t\t\t} else dfs2(y, num);",
			"\t\t}",
			"\t}",
			"\tTECC(const vector<vector<int>> &g): g(g), n(g.size()), used(n), comp(n, -1), ord(n), low(n), k(0) {",
			"\t\tint c = 0;",
			"\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\tif (used[i]) continue;",
			"\t\t\tdfs(i, -1, c);",
			"\t\t\tdfs2(i, k);",
			"\t\t\tk++;",
			"\t\t}",
			"\t}",
			"\t// build bridges tree",
			"\tvoid build_tree() {",
			"\t\tt.resize(k);",
			"\t\tfor (auto e : br) {",
			"\t\t\tint x = comp[e.first], y = comp[e.second];",
			"\t\t\tt[x].push_back(y);",
			"\t\t\tt[y].push_back(x);",
			"\t\t}",
			"\t}",
			"};",
			"void solve(int n, int m) {",
			"\tvector<vector<int>> g(n);",
			"\tfor (int i = 0; i < m; i++) {",
			"\t\tint a, b; cin >> a >> b;",
			"\t\tg[a].push_back(b);",
			"\t\tg[b].push_back(a);",
			"\t}",
			"\tTECC t(g);",
			"\tvector<vector<int>> ans(t.k);",
			"\tfor (int i = 0; i < n; i++) {",
			"\t\tans[t.comp[i]].push_back(i);",
			"\t}",
			"",
			"\tcout << ans.size() << '\\n';",
			"\tfor (auto x : ans) {",
			"\t\tcout << x.size();",
			"\t\tfor (auto y : x) cout << ' ' << y;",
			"\t\tcout << '\\n';",
			"\t}",
			"}",
		],
		"description": "Articulation Bridges and Bridge Tree"
	},
	"Articulation Points": {
		"prefix": "articulation points",
		"body": [
			"const int N = 3e5 + 9;",
			"",
			"// art = check an Articulation point.",
			"// low = maybe restore parent? and update parent of the current node to min(low[u], low[v])",
			"// dis = check whether a current vertex is visited or not.",
			"int T, low[N], dis[N], art[N];",
			"vector<int> g[N];",
			"void dfs(int u, int pre = 0) {",
			"\tlow[u] = dis[u] = ++T;",
			"\tint child = 0;",
			"\tfor(auto v : g[u]) {",
			"\t\tif(!dis[v]) {",
			"\t\t\tdfs(v, u);",
			"\t\t\tlow[u] = min(low[u], low[v]);",
			"\t\t\tif(low[v] >= dis[u] && pre != 0) art[u] = 1;",
			"\t\t\t++child;",
			"\t\t}",
			"\t\telse if(v != pre) low[u] = min(low[u], dis[v]);",
			"\t}",
			"\tif(pre == 0 && child > 1) art[u] = 1;",
			"}",
		],
		"description": "Articulation Points"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"const int N = 3e5 + 9, mod = 998244353;",
			"",
			"// you can delete 'cnt' vector if you don't need that",
			"int n, m;",
			"vector<pair<int, int>> g[N], r[N];",
			"vector<long long> dijkstra(int s, int t, vector<int> &cnt) {",
			"\tconst long long inf = 1e18;",
			"\tpriority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> q;",
			"\tvector<long long> d(n + 1, inf);",
			"\tvector<bool> vis(n + 1, 0);",
			"\tq.push({0, s});",
			"\td[s] = 0;",
			"\tcnt.resize(n + 1, 0); // number of shortest paths",
			"\tcnt[s] = 1;",
			"\twhile(!q.empty()) {",
			"\t\tauto x = q.top();",
			"\t\tq.pop();",
			"\t\tint u = x.second;",
			"\t\tif(vis[u]) continue;",
			"\t\tvis[u] = 1;",
			"\t\tfor(auto y: g[u]) {",
			"\t\t\tint v = y.first;",
			"\t\t\tlong long w = y.second;",
			"\t\t\tif(d[u] + w < d[v]) {",
			"\t\t\t\td[v] = d[u] + w;",
			"\t\t\t\tq.push({d[v], v});",
			"\t\t\t\tcnt[v] = cnt[u];",
			"\t\t\t} else if(d[u] + w == d[v]) cnt[v] = (cnt[v] + cnt[u]) % mod;",
			"\t\t}",
			"\t}",
			"\treturn d;",
			"}",
			"",
			"int u[N], v[N], w[N];",
			"",
			"void solve(int n, int m, int s, int t) {",
			"\tfor(int i = 1; i <= m; i++) {",
			"\t\tcin >> u[i] >> v[i] >> w[i];",
			"\t\tg[u[i]].push_back({v[i], w[i]});",
			"\t\tr[v[i]].push_back({u[i], w[i]});",
			"\t}",
			"\tvector<int> cnt1, cnt2;",
			"\tauto d1 = dijkstra(s, t, cnt1);",
			"\tauto d2 = dijkstra(t, s, cnt2);",
			"\t",
			"\tlong long ans = d1[t];",
			"\tfor(int i = 1; i <= m; i++) {",
			"\t\tint x = u[i], y = v[i];",
			"\t\tlong long nw = d1[x] + w[i] + d2[y];",
			"\t\tif(nw == ans && 1LL * cnt1[x] * cnt2[y] % mod == cnt1[t]) //YES",
			"\t\telse if(nw - ans + 1 < w[i]) // print nw - ans + 1",
			"\t\telse // No",
			"\t}",
			"}",
		],
		"description": "dijkstra implementation"
	},
	"Minimum & Maximum Spanning Tree": {
		"prefix": "mst",
		"body": [
			"struct DSU {",
			"\tvector<int> par, rnk, sz;",
			"\tint c;",
			"\tDSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {",
			"\t\tfor (int i = 1; i <= n; ++i) par[i] = i;",
			"\t}",
			"\tint find(int i) {",
			"\t\treturn (par[i] == i ? i : (par[i] = find(par[i])));",
			"\t}",
			"\tbool same(int i, int j) {",
			"\t\treturn find(i) == find(j);",
			"\t}",
			"\tint get_size(int i) {",
			"\t\treturn sz[find(i)];",
			"\t}",
			"\tint count() {",
			"\t\treturn c;",
			"\t}",
			"\tint unite(int i, int j) {",
			"\t\tif ((i = find(i)) == (j = find(j))) return -1;",
			"\t\telse --c;",
			"\t\tif (rnk[i] > rnk[j]) swap(i, j);",
			"\t\tpar[i] = j;",
			"\t\tsz[j] += sz[i];",
			"\t\tif (rnk[i] == rnk[j]) rnk[j]++;",
			"\t\treturn j;",
			"\t}",
			"};",
			"",
			"void mst(int n, int m) {",
			"\tvector<array<int, 3>> ed;",
			"\tfor (int i = 1; i < m + 1; i++) {",
			"\t\tint u, v, w;",
			"\t\tcin >> u >> v >> w;",
			"\t\ted.push_back({w, u, v});",
			"\t}",
			"\t// if you want to find Maximum Spanning Tree,",
			"\t// then you should sort all edge of graph ",
			"\t// in decreasing order of weights.",
			"\tsort(ed.begin(), ed.end());",
			"\tll ans = 0;",
			"\tDSU d(n);",
			"\tfor (auto e : ed) {",
			"\t\tint u = e[1], v = e[2], w = e[0];",
			"\t\tif (d.same(u, v)) continue;",
			"\t\tans += w;",
			"\t\td.unite(u, v);",
			"\t}",
			"\t//print ans",
			"}",
		],
		"description": "Minimum & Maximum Spanning Tree"
	},
	"2-SAT": {
		"prefix": "2sat",
		"body": [
			"/*",
			"zero Indexed",
			"we have vars variables",
			"F=(x_0 XXX y_0) and (x_1 XXX y_1) and ... (x_{vars-1} XXX y_{vars-1})",
			"here {x_i,y_i} are variables",
			"and XXX belongs to {OR,XOR}",
			"is there any assignment of variables such that F=true",
			"*/",
			"struct twosat {",
			"\tint n;  // total size combining +, -. must be even.",
			"\tvector<vector<int>> g, gt;",
			"\tvector<bool> vis, res;",
			"\tvector<int> comp;",
			"\tstack<int> ts;",
			"\ttwosat(int vars = 0) {",
			"\t\tn = vars << 1;",
			"\t\tg.resize(n);",
			"\t\tgt.resize(n);",
			"\t}",
			"",
			"\t//zero indexed, be careful",
			"\t//if you want to force variable a to be true in OR or XOR combination",
			"\t//add addOR (a,1,a,1);",
			"\t//if you want to force variable a to be false in OR or XOR combination",
			"\t//add addOR (a,0,a,0);",
			"",
			"\t//(x_a or (not x_b))-> af=1,bf=0",
			"\tvoid addOR(int a, bool af, int b, bool bf) {",
			"\t\ta += a + (af ^ 1);",
			"\t\tb += b + (bf ^ 1);",
			"\t\tg[a ^ 1].push_back(b);  // !a => b",
			"\t\tg[b ^ 1].push_back(a);  // !b => a",
			"\t\tgt[b].push_back(a ^ 1);",
			"\t\tgt[a].push_back(b ^ 1);",
			"\t}",
			"\t//(!x_a xor !x_b)-> af=0, bf=0",
			"\tvoid addXOR(int a, bool af, int b, bool bf) {",
			"\t\taddOR(a, af, b, bf);",
			"\t\taddOR(a, !af, b, !bf);",
			"\t}",
			"\tvoid _add(int a,bool af,int b,bool bf) {",
			"\t\ta += a + (af ^ 1);",
			"\t\tb += b + (bf ^ 1);",
			"\t\tg[a].push_back(b);",
			"\t\tgt[b].push_back(a);",
			"\t}",
			"\t//add this type of condition->",
			"\t//add(a,af,b,bf) means if a is af then b must need to be bf",
			"\tvoid add(int a,bool af,int b,bool bf) {",
			"\t\t_add(a, af, b, bf);",
			"\t\t_add(b, !bf, a, !af);",
			"\t}",
			"\tvoid dfs1(int u) {",
			"\t\tvis[u] = true;",
			"\t\tfor(int v : g[u]) if(!vis[v]) dfs1(v);",
			"\t\tts.push(u);",
			"\t}",
			"\tvoid dfs2(int u, int c) {",
			"\t\tcomp[u] = c;",
			"\t\tfor(int v : gt[u]) if(comp[v] == -1) dfs2(v, c);",
			"\t}",
			"\tbool ok() {",
			"\t\tvis.resize(n, false);",
			"\t\tfor(int i = 0; i < n; ++i) if(!vis[i]) dfs1(i);",
			"\t\tint scc = 0;",
			"\t\tcomp.resize(n, -1);",
			"\t\twhile(!ts.empty()) {",
			"\t\t\tint u = ts.top();",
			"\t\t\tts.pop();",
			"\t\t\tif(comp[u] == -1) dfs2(u, scc++);",
			"\t\t}",
			"\t\tres.resize(n / 2);",
			"\t\tfor(int i = 0; i < n; i += 2) {",
			"\t\t\tif(comp[i] == comp[i + 1]) return false;",
			"\t\t\tres[i / 2] = (comp[i] > comp[i + 1]);",
			"\t\t}",
			"\t\treturn true;",
			"\t}",
			"};",
			"void solve(int n, int m) {",
			"\ttwosat ts(n);",
			"\tfor(int i = 0; i < m; i++){",
			"\t\tint u, v, k; cin >> u >> v >> k;",
			"\t\t--u; --v;",
			"\t\tif(k) ts.add(u, 0, v, 0), ts.add(u, 1, v, 1), ts.add(v, 0, u, 0), ts.add(v, 1, u, 1);",
			"\t\telse ts.add(u, 0, v, 1), ts.add(u, 1, v, 0), ts.add(v, 0, u, 1), ts.add(v, 1, u, 0);",
			"\t}",
			"\tint k = ts.ok();",
			"\tif(!k) {",
			"\t\t// impossible",
			"\t} else {",
			"\t\tvector<int> v;",
			"\t\tfor(int i = 0; i < n; i++) if(ts.res[i]) v.push_back(i);",
			"\t\t// v size, element in v.",
			"\t}",
			"}",
		],
		"description": "2-SAT"
	},
	"Euler Path Directed": {
		"prefix": "euler path di",
		"body": [
			"const int N = 4e5 + 9;",
			"",
			"/*",
			"all the edges should be in the same connected component",
			"#directed graph: euler path: for all -> indeg = outdeg or nodes having indeg > outdeg = outdeg > indeg = 1 and for others in = out",
			"#directed graph: euler circuit: for all -> indeg = outdeg",
			"*/",
			"",
			"//euler path in a directed graph",
			"//it also finds circuit if it exists",
			"vector<int> g[N], ans;",
			"int done[N];",
			"void dfs(int u) {",
			"\twhile (done[u] < g[u].size()) dfs(g[u][done[u]++]);",
			"\tans.push_back(u);",
			"}",
			"",
			"int find(int n) {",
			"\tint edges = 0;",
			"\tvector<int> in(n + 1, 0), out(n + 1, 0);",
			"\tfor (int u = 1; u <= n; u++) {",
			"\t\tfor (auto v : g[u]) in[v]++, out[u]++, edges++;",
			"\t}",
			"\tint ok = 1, cnt1 = 0, cnt2 = 0, root = 0;",
			"\tfor (int i = 1; i <= n; i++) {",
			"\t\tif (in[i] - out[i] == 1) cnt1++;",
			"\t\tif (out[i] - in[i] == 1) cnt2++, root = i;",
			"\t\tif (abs(in[i] - out[i]) > 1) ok = 0;",
			"\t}",
			"\tif (cnt1 > 1 || cnt2 > 1) ok = 0;",
			"\tif (!ok) return 0;",
			"\tif (root == 0) {",
			"\t\tfor (int i = 1; i <= n; i++) if (out[i]) root = i;",
			"\t}",
			"\tif (root == 0) return 1; //empty graph",
			"\tdfs(root);",
			"\tif (ans.size() != edges + 1) return 0; //connectivity",
			"\treverse(ans.begin(), ans.end());",
			"\treturn 1;",
			"}",
			"",
			"void solve(int n, int m) {",
			"\tfor (int i = 1; i <= m; i++) {",
			"\t\tint u, v;",
			"\t\tcin >> u >> v;",
			"\t\tg[u].push_back(v);",
			"\t}",
			"\tint ok = find(n);",
			"\tif (!ok) {",
			"\t\t// No",
			"\t\treturn;",
			"\t}",
			"\t// Yes",
			"\t// The answer is in ans",
			"}",
		],
		"description": "Euler Path Directed"
	},
	"Euler Path Undirected": {
		"prefix": "euler path undi",
		"body": [
			"const int N = 5e3 + 9;",
			"",
			"/*",
			"all the edges should be in the same connected component",
			"#undirected graph: euler path: all degrees are even or exactly two of them are odd.",
			"#undirected graph: euler circuit: all degrees are even",
			"*/",
			"",
			"//euler path in an undirected graph",
			"//it also finds circuit if it exists",
			"vector<pair<int, int>> g[N];",
			"vector<int> ans;",
			"int done[N];",
			"int vis[N * N]; //number of edges",
			"void dfs(int u) {",
			"\twhile (done[u] < g[u].size()) {",
			"\t\tauto e = g[u][done[u]++];",
			"\t\tif (vis[e.second]) continue;",
			"\t\tvis[e.second] = 1;",
			"\t\tdfs(e.first);",
			"\t}",
			"\tans.push_back(u);",
			"}",
			"",
			"int find(int n) {",
			"\tint edges = 0;",
			"\tans.clear();",
			"\tmemset(done, 0, sizeof(done));",
			"\tmemset(vis, 0, sizeof(vis));",
			"\tvector<int> deg(n + 1, 0);",
			"\tfor (int u = 1; u <= n; u++) {",
			"\t\tfor (auto e : g[u]) {",
			"\t\t\tdeg[e.first]++, deg[u]++, edges++;",
			"\t\t}",
			"\t}",
			"\tint odd = 0, root = 0;",
			"\tfor (int i = 1; i <= n; i++) {",
			"\t\tif (deg[i] & 1) odd++, root = i;",
			"\t}",
			"\tif (odd > 2) return 0;",
			"\tif (root == 0) {",
			"\t\tfor (int i = 1; i <= n; i++) if (deg[i]) root = i;",
			"\t}",
			"\tif (root == 0) return 1; //empty graph",
			"\tdfs(root);",
			"\tif (ans.size() != edges / 2 + 1) return 0;",
			"\treverse(ans.begin(), ans.end());",
			"\treturn 1;",
			"}",
			"",
			"void solve(int n, int m) {",
			"\tvector<int> deg(n + 1, 0);",
			"\tfor (int i = 1; i <= m; i++) {",
			"\t\tint u, v;",
			"\t\tcin >> u >> v;",
			"\t\tg[u].push_back({v, i});",
			"\t\tg[v].push_back({u, i});",
			"\t\tdeg[u]++, deg[v]++;",
			"\t}",
			"\tint sz = m;",
			"\tfor (int i = 1; i <= n; i++) {",
			"\t\tif (deg[i] & 1) {",
			"\t\t\t++sz;",
			"\t\t\tg[n + 1].push_back({i, sz});",
			"\t\t\tg[i].push_back({n + 1, sz});",
			"\t\t}",
			"\t}",
			"\tint ok = find(n + 1);",
			"\tassert(ok);",
			"\t// indegree, outdegree",
			"\tvector<int> in(n + 2, 0), out(n + 2, 0);",
			"\tfor (int i = 0; i + 1 < ans.size(); i++) {",
			"\t\tif (ans[i] != n + 1 && ans[i + 1] != n + 1) {",
			"\t\t\tin[ans[i + 1]]++;",
			"\t\t\tout[ans[i]]++;",
			"\t\t}",
			"\t}",
			"\t// The answer is in in, out, ans",
			"}",
		],
		"description": "Euler Path Undirected"
	},
	"Tree Diameter": {
		"prefix": "tree diameter",
		"body": [
			"const int N = 2e5 + 9;",
			"",
			"vector<int> g[N];",
			"int farthest(int s, int n, vector<int> &d) {",
			"\tstatic const int inf = N;",
			"\td.assign(n + 1, inf); d[s] = 0;",
			"\tvector<bool> vis(n + 1);",
			"\tqueue<int> q; q.push(s);",
			"\tvis[s] = 1; int last = s;",
			"\twhile (!q.empty()) {",
			"\t\tint u = q.front(); q.pop();",
			"\t\tfor (int v : g[u]) {",
			"\t\t\tif (vis[v]) continue;",
			"\t\t\td[v] = d[u] + 1;",
			"\t\t\tq.push(v); vis[v] = 1;",
			"\t\t}",
			"\t\tlast = u;",
			"\t}",
			"\treturn last;",
			"}",
			"",
			"void solve(int n) {",
			"\tfor (int i = 1; i < n; i++) {",
			"\t\tint u, v; cin >> u >> v;",
			"\t\tg[u].push_back(v);",
			"\t\tg[v].push_back(u);",
			"\t}",
			"\tvector<int> dx, dy;",
			"\tint x = farthest(1, n, dx);",
			"\tint y = farthest(x, n, dx);",
			"\tfarthest(y, n, dy);",
			"\tint ans = 0;",
			"\tfor (int i = 1; i < n + 1; i++) ans = max(dy[i], ans);",
			"\t// print ans.",
			"}",
		],
		"description": "Tree Diameter"
	},
	"Sieve": {
		"prefix": "sieve",
		"body": [
			"const int N = 1e6 + 9;",
			"",
			"vector<int> primes;",
			"bool is_prime[N];",
			"// use bitset<N> is_prime; to have O(N/64) memory complexity",
			"// using bitset you can solve upto around N = 10^8 in 1s",
			"void sieve_v0() {",
			"\tfor (int i = 2; i < N; i++) {",
			"\t\tis_prime[i] = true;",
			"\t}",
			"\tfor (int i = 2; i * i < N; i++) {",
			"\t\tif (is_prime[i]) {",
			"\t\t\tfor (int j = i * i; j < N; j += i) {",
			"\t\t\t\tis_prime[j] = false;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tfor (int i = 2; i < N; i++) {",
			"\t\tif (is_prime[i]) {",
			"\t\t\tprimes.push_back(i);",
			"\t\t}",
			"\t}",
			"}",
			"",
			"// sieve with smallest prime factors (spf)",
			"int spf[N];",
			"void sieve() {",
			"\tfor (int i = 2; i < N; i++) {",
			"\t\tspf[i] = i;",
			"\t}",
			"\tfor (int i = 2; i * i < N; i++) {",
			"\t\tif (spf[i] == i) {",
			"\t\t\tfor (int j = i * i; j < N; j += i) {",
			"\t\t\t\tspf[j] = min(spf[j], i);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tfor (int i = 2; i < N; i++) {",
			"\t\tif (spf[i] == i) {",
			"\t\t\tprimes.push_back(i);",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "Sieve"
	},
	"Linear Sieve": {
		"prefix": "linear sieve",
		"body": [
			"const int N = 1e5 + 9;",
			"",
			"int spf[N];",
			"vector<int> primes;",
			"void sieve() {",
			"\tfor(int i = 2; i < N; i++) {",
			"\t\tif (spf[i] == 0) spf[i] = i, primes.push_back(i);",
			"\t\tint sz = primes.size();",
			"\t\tfor (int j = 0; j < sz && i * primes[j] < N && primes[j] <= spf[i]; j++) {",
			"\t\t\tspf[i * primes[j]] = primes[j];",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "Linear Sieve"
	},
	"Segmented Sieve": {
		"prefix": "segmented sieve",
		"body": [
			"// Generate all primes up to limit using sieve of eratosthenes",
			"vector<int> sieve(int limit) {",
			"\tvector<bool> is_prime(limit + 1, true);",
			"\tis_prime[0] = is_prime[1] = false;",
			"\tfor (int p = 2; p * p <= limit; ++p) {",
			"\t\tif (is_prime[p]) {",
			"\t\t\tfor (int i = p * p; i <= limit; i += p) {",
			"\t\t\t\tis_prime[i] = false;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvector<int> primes;",
			"\tfor (int p = 2; p <= limit; ++p) {",
			"\t\tif (is_prime[p]) {",
			"\t\t\tprimes.push_back(p);",
			"\t\t}",
			"\t}",
			"\treturn primes;",
			"}",
			"",
			"// Generate all primes from l to r using segmented sieve in O((r - l) log (r) + sqrt(r))",
			"vector<ll> segmented_sieve(ll l, ll r) {",
			"\tif (l == 1) {",
			"\t\tl++;",
			"\t}",
			"\tint limit = sqrtl(r);",
			"\twhile ((ll) limit * limit <= r) limit++;",
			"\twhile ((ll) limit * limit > r) limit--;",
			"\tauto primes = sieve(limit);",
			"\tvector<bool> is_prime(r - l + 1, true);",
			"\tfor (ll p : primes) {",
			"\t\tll start = max((ll)p * p, (ll)(l + p - 1) / p * p);",
			"\t\tfor (ll j = start; j <= r; j += p) {",
			"\t\t\tis_prime[j - l] = false;",
			"\t\t}",
			"\t}",
			"\tvector<ll> vec;",
			"\tfor (ll i = l; i <= r; ++i) {",
			"\t\tif (is_prime[i - l]) {",
			"\t\t\tvec.push_back(i);",
			"\t\t}",
			"\t}",
			"\treturn vec;",
			"}",
		],
		"description": "Segmented Sieve"
	},
	"Counting Divisors": {
		"prefix": "counting divisors",
		"body": [
				"// you can restore any Divisors",
				"ll numberOfDivisors(ll num) {",
				"\tll total = 1;",
				"\tfor (int i = 2; (ll)i * i <= num; i++) {",
				"\t\tif (num % i == 0) {",
				"\t\t\tint e = 0;",
				"\t\t\tdo {",
				"\t\t\t\te++;",
				"\t\t\t\tnum /= i;",
				"\t\t\t} while (num % i == 0);",
				"\t\t\ttotal *= e + 1;",
				"\t\t}",
				"\t}",
				"\tif (num > 1) {",
				"\t\ttotal *= 2;",
				"\t}",
				"\treturn total;",
				"}",
		],
		"description": "Counting Divisors"
	},
	"Sum of Divisors": {
		"prefix": "sum of divisors",
		"body": [
			"ll SumOfDivisors(ll num) {",
			"\tll total = 1;",
			"",
			"\tfor (int i = 2; (ll)i * i <= num; i++) {",
			"\t\tif (num % i == 0) {",
			"\t\t\tint e = 0;",
			"\t\t\tdo {",
			"\t\t\t\te++;",
			"\t\t\t\tnum /= i;",
			"\t\t\t} while (num % i == 0);",
			"",	
			"\t\t\tll sum = 0, pow = 1;",
			"\t\t\tdo {",
			"\t\t\t\tsum += pow;",
			"\t\t\t\tpow *= i;",
			"\t\t\t} while (e-- > 0);",
			"\t\t\ttotal *= sum;",
			"\t\t}",
			"\t}",
			"\tif (num > 1) {",
			"\t\ttotal *= (1 + num);",
			"\t}",
			"\treturn total;",
			"}",
		],
		"description": "Sum of Divisors"
	},
	"Pisano Period": {
		"prefix": "pisano",
		"body": [
			"// return pisano period(maybe you can modify m * m to m + m in 'for')",
			"// then you should calculate fibbonacci value at most Pth (P is pisano period)",
			"// and just find i%pth fibbonacci value. That's collect value.",
			"ll pisano(ll m) {",
			"\tll previous = 0;",
			"\tll cur = 1;",
			"\tll temp;",
			"",
			"\tfor (ll i = 0; i < m * m; i++) {",
			"\t\ttemp = (previous + cur) % m;",
			"\t\tprevious = cur;",
			"\t\tcur = temp;",
			"",
			"\t\t// found pisano period",
			"\t\tif (previous == 0 && cur == 1) {",
			"\t\t\treturn i + 1;",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"Lazy_SEG": {
		"prefix": "lazy seg",
		"body": [
			"const int N = 5e5 + 9;",
			"int a[N];",
			"struct ST {",
			"\t#define lc (n << 1)",
			"\t#define rc ((n << 1) | 1)",
			"\tlong long t[4 * N], lazy[4 * N];",
			"\tST() {",
			"\t\tmemset(t, 0, sizeof t);",
			"\t\tmemset(lazy, 0, sizeof lazy);",
			"\t}",
			"\tinline void push(int n, int b, int e) {",
			"\t\tif (lazy[n] == 0) return;",
			"\t\tt[n] = t[n] + lazy[n] * (e - b + 1);",
			"\t\tif (b != e) {",
			"\t\t\tlazy[lc] = lazy[lc] + lazy[n];",
			"\t\t\tlazy[rc] = lazy[rc] + lazy[n];",
			"\t\t}",
			"\t\tlazy[n] = 0;",
			"\t}",
			"\tinline long long combine(long long a,long long b) {",
			"\t\treturn a + b;",
			"\t}",
			"\tinline void pull(int n) {",
			"\t\tt[n] = t[lc] + t[rc];",
			"\t}",
			"\tvoid build(int n, int b, int e) {",
			"\t\tlazy[n] = 0;",
			"\t\tif (b == e) {",
			"\t\t\tt[n] = a[b];",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = (b + e) >> 1;",
			"\t\tbuild(lc, b, mid);",
			"\t\tbuild(rc, mid + 1, e);",
			"\t\tpull(n);",
			"\t}",
			"\tvoid upd(int n, int b, int e, int i, int j, long long v) {",
			"\t\tpush(n, b, e);",
			"\t\tif (j < b || e < i) return;",
			"\t\tif (i <= b && e <= j) {",
			"\t\t\tlazy[n] = v; //set lazy",
			"\t\t\tpush(n, b, e);",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = (b + e) >> 1;",
			"\t\tupd(lc, b, mid, i, j, v);",
			"\t\tupd(rc, mid + 1, e, i, j, v);",
			"\t\tpull(n);",
			"\t}",
			"\tlong long query(int n, int b, int e, int i, int j) {",
			"\t\tpush(n, b, e);",
			"\t\tif (i > e || b > j) return 0; //return null",
			"\t\tif (i <= b && e <= j) return t[n];",
			"\t\tint mid = (b + e) >> 1;",
			"\t\treturn combine(query(lc, b, mid, i, j), query(rc, mid + 1, e, i, j));",
			"\t}",
			"};",
		],
		"description": "Lazy_SEG"
	},
	"Number of divisors": {
		"prefix": "number of divisors",
		"body": [
			"ll numberOfDivisors(ll num) {",
			"\tll total = 1;",
			"\tfor (int i = 2; (ll)i * i <= num; i++) {",
			"\t\tif (num % i == 0) {",
			"\t\t\tint e = 0;",
			"\t\t\tdo {",
			"\t\t\t\te++;",
			"\t\t\t\tnum /= i;",
			"\t\t\t} while (num % i == 0);",
			"\t\t\ttotal *= e + 1;",
			"\t\t}",
			"\t}",
			"\tif (num > 1) {",
			"\t\ttotal *= 2;",
			"\t}",
			"\treturn total;",
			"}",
		],
		"description": "Number of divisors"
	},
	"Prime test": {
		"prefix": "prime test",
		"body": [
			"bool prime_test(ll n) {",
			"\tif (n < 2) return false;",
			"\tif (n == 2) return true;",
			"\tif (n % 2 == 0) return false;",
			"\tfor (ll x = 3; x * x <= n; x += 2) {",
			"\t\tif (n % x == 0) return false;",
			"\t}",
			"\treturn true;",
			"}",
		],
		"description": "prime_test"
	},
	"Sum of divisors": {
		"prefix": "sum of divisors",
		"body": [
			"ll SumOfDivisors(ll num) {",
			"\tll total = 1;",
			"",
			"\tfor (int i = 2; (ll)i * i <= num; i++) {",
			"\t\tif (num % i == 0) {",
			"\t\t\tint e = 0;",
			"\t\t\tdo {",
			"\t\t\t\te++;",
			"\t\t\t\tnum /= i;",
			"\t\t\t}",
			"\t\t\twhile (num % i == 0);",
			"",
			"\t\t\tll sum = 0, pow = 1;",
			"\t\t\tdo {",
			"\t\t\t\tsum += pow;",
			"\t\t\t\tpow *= i;",
			"\t\t\t}",
			"\t\t\twhile (e-- > 0);",
			"\t\t\ttotal *= sum;",
			"\t\t}",
			"\t}",
			"\tif (num > 1) {",
			"\t\ttotal *= (1 + num);",
			"\t}",
			"\treturn total;",
			"}",
		],
		"description": "Sum of divisors"
	},
	"Euler totient funtion": {
		"prefix": "totient",
		"body": [
			"struct totient {",
			"\ttotient() {}",
			"",
			"\tint phi(int n) {",
			"\t\tint result = n;",
			"\t\tfor (int i = 2; (ll) i * i <= n; i++) {",
			"\t\t\tif (n % i == 0) {",
			"\t\t\t\twhile (n % i == 0) {",
			"\t\t\t\t\tn /= i;",
			"\t\t\t\t}",
			"\t\t\t\tresult -= result / i;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (n > 1)",
			"\t\t\tresult -= result / n;",
			"\t\treturn result;",
			"\t}",
			"",
			"\t// find Euler totient function using Sieve of Eratosthenes",
			"\t// from 1 to n in O(n loglogn)",
			"\tvector<int> phi_1_to_n_sieve(int n) {",
			"\t\tvector<int> phi(n + 1);",
			"\t\tfor (int i = 0; i <= n; i++)",
			"\t\t\tphi[i] = i;",
			"",
			"\t\tfor (int i = 2; i <= n; i++) {",
			"\t\t\tif (phi[i] == i) {",
			"\t\t\t\tfor (int j = i; j <= n; j += i)",
			"\t\t\t\t\t\tphi[j] -= phi[j] / i;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn phi;",
			"\t}",
			"",
			"\t// find Euler totient function using the divisor sum property",
			"\t// from 1 to n in O(n logln)",
			"\tvector<int> phi_1_to_n_divisor(int n) {",
			"\t\tvector<int> phi(n + 1);",
			"\t\tphi[0] = 0;",
			"\t\tphi[1] = 1;",
			"\t\tfor (int i = 2; i <= n; i++) {",
			"\t\t\tphi[i] = i - 1;",
			"\t\t}",
			"",
			"\t\tfor (int i = 2; i <= n; i++) {",
			"\t\t\tfor (int j = 2 * i; j <= n; j += i) {",
			"\t\t\t\tphi[j] -= phi[i];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn phi;",
			"\t}",
			"};",
		],
		"description": "Euler totient funtion"
	},
	"KMP": {
		"prefix": "kmp",
		"body": [
			"struct kmp {",
			"\tconst int N = 3e5 + 9;",
			"\tvector<int> ans;",
			"\t// returns the longest proper prefix array of pattern p",
			"\t// where lps[i]=longest proper prefix which is also suffix of p[0...i]",
			"\tvector<int> build_lps(string p) {",
			"\t\tint sz = p.size();",
			"\t\tvector<int> lps;",
			"\t\tlps.assign(sz + 1, 0);",
			"\t\tint j = 0;",
			"\t\tlps[0] = 0;",
			"",
			"\t\tfor(int i = 1; i < sz; i++) {",
			"\t\t\twhile(j >= 0 && p[i] != p[j]) {",
			"\t\t\t\tif(j >= 1) j = lps[j - 1];",
			"\t\t\t\telse j = -1;",
			"\t\t\t}",
			"\t\t\tj++;",
			"\t\t\tlps[i] = j;",
			"\t\t}",
			"\t\treturn lps;",
			"\t}",
			"",
			"\t// returns matches in vector ans in 0-indexed",
			"\tvoid find(vector<int> lps, string s, string p) {",
			"\t\tint psz = p.size(), sz = s.size();",
			"\t\tint j = 0;",
			"",
			"\t\tfor(int i = 0; i < sz; i++) {",
			"\t\t\twhile(j >= 0 && p[j] != s[i]) {",
			"\t\t\t\tif(j >= 1) j = lps[j - 1];",
			"\t\t\t\telse j = -1;",
			"\t\t\t}",
			"\t\t\tj++;",
			"\t\t\tif(j == psz) {",
			"\t\t\t\tj = lps[j - 1];",
			"\t\t\t\t// pattern found in string s at position i-psz+1",
			"\t\t\t\tans.push_back(i - psz + 1);",
			"\t\t\t}",
			"\t\t\t// after each loop we have j=longest common suffix of s[0..i] which is also prefix of p",
			"\t\t}",
			"\t}",
			"};",
		],
		"description": "KMP"
	},	
	"Extended euclid": {
		"prefix": "extended euclid",
		"body": [
			"struct extended_euclid {",
			"\t// find a way to represent GCD in terms of a and b, i.e. coefficients x and y for which:",
			"\t// a * x + b * y = gcd(a, b)",
			"\tll find_cofficients(ll a, ll b, ll &x, ll &y) {",
			"\t\tif (b == 0) {",
			"\t\t\tx = 1; y = 0;",
			"\t\t\treturn a;",
			"\t\t}",
			"\t\tll x1, y1;",
			"\t\tll d = find_cofficients(b, a % b, x1, y1);",
			"\t\tx = y1;",
			"\t\ty = x1 - y1 * (a / b);",
			"\t\treturn d;",
			"\t}",
			"\t// iterative version. It will run a little bit faster than find_cofficionts.",
			"\tll find_cofficients1(ll a, ll b, ll& x, ll& y) {",
			"\t\tx = 1, y = 0;",
			"\t\tll x1 = 0, y1 = 1, a1 = a, b1 = b;",
			"\t\twhile (b1) {",
			"\t\t\tll q = a1 / b1;",
			"\t\t\ttie(x, x1) = make_tuple(x1, x - q * x1);",
			"\t\t\ttie(y, y1) = make_tuple(y1, y - q * y1);",
			"\t\t\ttie(a1, b1) = make_tuple(b1, a1 - q * b1);",
			"\t\t}",
			"\t\treturn a1;",
			"\t}",
			"\t// Modular Inverse",
			"\tll inverse(ll a, ll m) {",
			"\t\tll x, y;",
			"\t\tll g = find_cofficients(a, m, x, y);",
			"\t\tif (g != 1) return -1;",
			"\t\treturn (x % m + m) % m;",
			"\t}",
			"};",
		],
		"description": "Extended euclid"
	},
	"Suffix array": {
		"prefix": "suffix array",
		"body": [
			"namespace suffixarray {",
			"\tconst int N = 3e5 + 9;",
			"\tconst int LG = 18;",
			"",
			"\tvoid induced_sort(const vector<int> &vec, int val_range, vector<int> &SA, const vector<bool> &sl, const vector<int> &lms_idx) {",
			"\t\tvector<int> l(val_range, 0), r(val_range, 0);",
			"\t\tfor (int c : vec) {",
			"\t\t\tif (c + 1 < val_range) ++l[c + 1];",
			"\t\t\t++r[c];",
			"\t\t}",
			"\t\tpartial_sum(l.begin(), l.end(), l.begin());",
			"\t\tpartial_sum(r.begin(), r.end(), r.begin());",
			"\t\tfill(SA.begin(), SA.end(), -1);",
			"\t\tfor (int i = lms_idx.size() - 1; i >= 0; --i)",
			"\t\t\tSA[--r[vec[lms_idx[i]]]] = lms_idx[i];",
			"\t\tfor (int i : SA) {",
			"\t\t\tif (i >= 1 && sl[i - 1]) {",
			"\t\t\t\tSA[l[vec[i - 1]]++] = i - 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tfill(r.begin(), r.end(), 0);",
			"\t\tfor (int c : vec) ++r[c];",
			"\t\tpartial_sum(r.begin(), r.end(), r.begin());",
			"\t\tfor (int k = SA.size() - 1, i = SA[k]; k >= 1; --k, i = SA[k]) {",
			"\t\t\tif (i >= 1 && !sl[i - 1]) {",
			"\t\t\t\tSA[--r[vec[i - 1]]] = i - 1;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvector<int> SA_IS(const vector<int> &vec, int val_range) {",
			"\t\tconst int n = vec.size();",
			"\t\tvector<int> SA(n), lms_idx;",
			"\t\tvector<bool> sl(n);",
			"\t\tsl[n - 1] = false;",
			"\t\tfor (int i = n - 2; i >= 0; --i) {",
			"\t\t\tsl[i] = (vec[i] > vec[i + 1] || (vec[i] == vec[i + 1] && sl[i + 1]));",
			"\t\t\tif (sl[i] && !sl[i + 1]) lms_idx.push_back(i + 1);",
			"\t\t}",
			"\t\treverse(lms_idx.begin(), lms_idx.end());",
			"\t\tinduced_sort(vec, val_range, SA, sl, lms_idx);",
			"\t\tvector<int> new_lms_idx(lms_idx.size()), lms_vec(lms_idx.size());",
			"\t\tfor (int i = 0, k = 0; i < n; ++i) {",
			"\t\t\tif (!sl[SA[i]] && SA[i] >= 1 && sl[SA[i] - 1]) {",
			"\t\t\t\tnew_lms_idx[k++] = SA[i];",
			"\t\t\t}",
			"\t\t}",
			"\t\tint cur = 0;",
			"\t\tSA[n - 1] = cur;",
			"\t\tfor (size_t k = 1; k < new_lms_idx.size(); ++k) {",
			"\t\t\tint i = new_lms_idx[k - 1], j = new_lms_idx[k];",
			"\t\t\tif (vec[i] != vec[j]) {",
			"\t\t\t\tSA[j] = ++cur;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tbool flag = false;",
			"\t\t\tfor (int a = i + 1, b = j + 1;; ++a, ++b) {",
			"\t\t\t\tif (vec[a] != vec[b]) {",
			"\t\t\t\t\tflag = true;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t\t\tif ((!sl[a] && sl[a - 1]) || (!sl[b] && sl[b - 1])) {",
			"\t\t\t\t\tflag = !((!sl[a] && sl[a - 1]) && (!sl[b] && sl[b - 1]));",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tSA[j] = (flag ? ++cur : cur);",
			"\t\t}",
			"\t\tfor (size_t i = 0; i < lms_idx.size(); ++i) {",
			"\t\t\tlms_vec[i] = SA[lms_idx[i]];",
			"\t\t}",
			"\t\tif (cur + 1 < (int)lms_idx.size()) {",
			"\t\t\tauto lms_SA = SA_IS(lms_vec, cur + 1);",
			"\t\t\tfor (size_t i = 0; i < lms_idx.size(); ++i) {",
			"\t\t\tnew_lms_idx[i] = lms_idx[lms_SA[i]];",
			"\t\t\t}",
			"\t\t}",
			"\t\tinduced_sort(vec, val_range, SA, sl, new_lms_idx);",
			"\t\treturn SA;",
			"\t}",
			"\tvector<int> suffix_array(const string &s, const int LIM = 128) {",
			"\t\tvector<int> vec(s.size() + 1);",
			"\t\tcopy(begin(s), end(s), begin(vec));",
			"\t\tvec.back() = '!';",
			"\t\tauto ret = SA_IS(vec, LIM);",
			"\t\tret.erase(ret.begin());",
			"\t\treturn ret;",
			"\t}",
			"\tstruct SuffixArray {",
			"\t\tint n;",
			"\t\tstring s;",
			"\t\tvector<int> sa, rank, lcp;",
			"\t\tvector<vector<int>> t;",
			"\t\tvector<int> lg;",
			"\t\tSuffixArray() {}",
			"\t\tSuffixArray(string _s) {",
			"\t\t\tn = _s.size();",
			"\t\t\ts = _s;",
			"\t\t\tsa = suffix_array(s);",
			"\t\t\trank.resize(n);",
			"\t\t\tfor (int i = 0; i < n; i++) rank[sa[i]] = i;",
			"\t\t\tcostruct_lcp();",
			"\t\t\tprec();",
			"\t\t\tbuild();",
			"\t\t}",
			"\t\tvoid costruct_lcp() {",
			"\t\t\tint k = 0;",
			"\t\t\tlcp.resize(n - 1, 0);",
			"\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\tif (rank[i] == n - 1) {",
			"\t\t\t\t\tk = 0;",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\tint j = sa[rank[i] + 1];",
			"\t\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;",
			"\t\t\t\tlcp[rank[i]] = k;",
			"\t\t\t\tif (k) k--;",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid prec() {",
			"\t\t\tlg.resize(n, 0);",
			"\t\t\tfor (int i = 2; i < n; i++) lg[i] = lg[i / 2] + 1;",
			"\t\t}",
			"\t\tvoid build() {",
			"\t\t\tint sz = n - 1;",
			"\t\t\tt.resize(sz);",
			"\t\t\tfor (int i = 0; i < sz; i++) {",
			"\t\t\t\tt[i].resize(LG);",
			"\t\t\t\tt[i][0] = lcp[i];",
			"\t\t\t}",
			"\t\t\tfor (int k = 1; k < LG; ++k) {",
			"\t\t\t\tfor (int i = 0; i + (1 << k) - 1 < sz; ++i) {",
			"\t\t\t\t\tt[i][k] = min(t[i][k - 1], t[i + (1 << (k - 1))][k - 1]);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tint query(int l, int r) { // minimum of lcp[l], ..., lcp[r]",
			"\t\t\tint k = lg[r - l + 1];",
			"\t\t\treturn min(t[l][k], t[r - (1 << k) + 1][k]);",
			"\t\t}",
			"\t\tint get_lcp(int i, int j) { // lcp of suffix starting from i and j",
			"\t\t\tif (i == j) return n - i;",
			"\t\t\tint l = rank[i], r = rank[j];",
			"\t\t\tif (l > r) swap(l, r);",
			"\t\t\treturn query(l, r - 1);",
			"\t\t}",
			"\t\tint lower_bound(string &t) {",
			"\t\t\tint l = 0, r = n - 1, k = t.size(), ans = n;",
			"\t\t\twhile (l <= r) {",
			"\t\t\t\tint mid = l + r >> 1;",
			"\t\t\t\tif (s.substr(sa[mid], min(n - sa[mid], k)) >= t) ans = mid, r = mid - 1;",
			"\t\t\t\telse l = mid + 1;",
			"\t\t\t}",
			"\t\t\treturn ans;",
			"\t\t}",
			"\t\tint upper_bound(string &t) {",
			"\t\t\tint l = 0, r = n - 1, k = t.size(), ans = n;",
			"\t\t\twhile (l <= r) {",
			"\t\t\t\tint mid = l + r >> 1;",
			"\t\t\t\tif (s.substr(sa[mid], min(n - sa[mid], k)) > t) ans = mid, r = mid - 1;",
			"\t\t\t\telse l = mid + 1;",
			"\t\t\t}",
			"\t\t\treturn ans;",
			"\t\t}",
			"\t\t// occurrences of s[p, ..., p + len - 1]",
			"\t\tpair<int, int> find_occurrence(int p, int len) {",
			"\t\t\tp = rank[p];",
			"\t\t\tpair<int, int> ans = {p, p};",
			"\t\t\tint l = 0, r = p - 1;",
			"\t\t\twhile (l <= r) {",
			"\t\t\t\tint mid = l + r >> 1;",
			"\t\t\t\tif (query(mid, p - 1) >= len) ans.first = mid, r = mid - 1;",
			"\t\t\t\telse l = mid + 1;",
			"\t\t\t}",
			"\t\t\tl = p + 1, r = n - 1;",
			"\t\t\twhile (l <= r) {",
			"\t\t\t\tint mid = l + r >> 1;",
			"\t\t\t\tif (query(p, mid - 1) >= len) ans.second = mid, l = mid + 1;",
			"\t\t\t\telse r = mid - 1;",
			"\t\t\t}",
			"\t\t\treturn ans;",
			"\t\t}",
			"\t};",
			"}",
		],
		"description": "Suffix array structure"
	},
	"Linear Congruence Equation": {
		"prefix": "lce",
		"body": [
			"struct LCE {",
			"\tll extended_euclid(ll a, ll b, ll &x, ll &y) {",
			"\t\tif (b == 0) {",
			"\t\t\tx = 1; y = 0;",
			"\t\t\treturn a;",
			"\t\t}",
			"\t\tll x1, y1;",
			"\t\tll d = extended_euclid(b, a % b, x1, y1);",
			"\t\tx = y1;",
			"\t\ty = x1 - y1 * (a / b);",
			"\t\treturn d;",
			"\t}",
			"\tll inverse(ll a, ll m) {",
			"\t\tll x, y;",
			"\t\tll g = extended_euclid(a, m, x, y);",
			"\t\tif (g != 1) return -1;",
			"\t\treturn (x % m + m) % m;",
			"\t}",
			"\t// ax = b (mod m)",
			"\tvector<ll> congruence_equation(ll a, ll b, ll m) {",
			"\t\tvector<ll> ret;",
			"\t\tll g = gcd(a, m), x;",
			"\t\tif (b % g != 0) return ret;",
			"\t\ta /= g, b /= g;",
			"\t\tx = inverse(a, m / g) * b;",
			"\t\tfor (int k = 0; k < g; ++k) { // exactly g solutions",
			"\t\t\tret.push_back((x + m / g * k) % m);",
			"\t\t}",
			"\t\t// minimum solution = (m / g - (m - x) % (m / g)) % (m / g)",
			"\t\treturn ret;",
			"\t}",
			"};",
		],
		"description": "Linear Congruence Equation"
	},
	"Chinese Remainder Theorem": {
		"prefix": "crt",
		"body": [
			"using T = __int128;",
			"// ax + by = __gcd(a, b)",
			"// returns __gcd(a, b)",
			"struct crt {",
			"\tT extended_euclid(T a, T b, T &x, T &y) {",
			"\t\tT xx = y = 0;",
			"\t\tT yy = x = 1;",
			"\t\twhile (b) {",
			"\t\t\tT q = a / b;",
			"\t\t\tT t = b; b = a % b; a = t;",
			"\t\t\tt = xx; xx = x - q * xx; x = t;",
			"\t\t\tt = yy; yy = y - q * yy; y = t;",
			"\t\t}",
			"\t\treturn a;",
			"\t}",
			"\t// finds x such that x % m1 = a1, x % m2 = a2. m1 and m2 may not be coprime",
			"\t// here, x is unique modulo m = lcm(m1, m2). returns (x, m). on failure, m = -1.",
			"\tpair<T, T> CRT(T a1, T m1, T a2, T m2) {",
			"\t\tT p, q;",
			"\t\tT g = extended_euclid(m1, m2, p, q);",
			"\t\tif (a1 % g != a2 % g) return make_pair(0, -1);",
			"\t\tT m = m1 / g * m2;",
			"\t\tp = (p % m + m) % m;",
			"\t\tq = (q % m + m) % m;",
			"\t\treturn make_pair((p * a2 % m * (m1 / g) % m + q * a1 % m * (m2 / g) % m) %  m, m);",
			"\t}",
			"\t// intersecting AP of two APs: (a1 + d1x) and (a2 + d2x)",
			"\tpair<ll, ll> intersect(ll a1, ll d1, ll a2, ll d2) {",
			"\t\tauto x = CRT(a1 % d1, d1, a2 % d2, d2);",
			"\t\tll a = x.first, d = x.second;",
			"\t\tif (d == -1) return {0, 0}; // empty",
			"\t\tll st = max(a1, a2);",
			"\t\ta = a < st ? a + ((st - a + d - 1) / d) : a; // while (a < st) a += d;",
			"\t\treturn {a, d};",
			"\t}",
			"};",
		],
		"description": "Chinese Remainder Theorem & intersection of two arithmetic progressions"
	},
	"Linear Diophantine Equation": {
		"prefix": "linear diophantine equation",
		"body": [
			"ll extended_euclid(ll a, ll b, ll &x, ll &y) {",
			"\tll xx = y = 0;",
			"\tll yy = x = 1;",
			"\twhile (b) {",
			"\t\tll q = a / b;",
			"\t\tll t = b; b = a % b; a = t;",
			"\t\tt = xx; xx = x - q * xx; x = t;",
			"\t\tt = yy; yy = y - q * yy; y = t;",
			"\t}",
			"\treturn a;",
			"}",
			"// a*x+b*y=c. returns valid x and y if possible.",
			"// all solutions are of the form (x0 + k * b / g, y0 - k * b / g)",
			"bool find_any_solution (ll a, ll b, ll c, ll &x0, ll &y0, ll &g) {",
			"\tif (a == 0 and b == 0) {",
			"\t\tif (c) return false;",
			"\t\tx0 = y0 = g = 0; ",
			"\t\treturn true;",
			"\t}",
			"\tg = extended_euclid (abs(a), abs(b), x0, y0);",
			"\tif (c % g != 0) return false;",
			"\tx0 *= c / g;",
			"\ty0 *= c / g;",
			"\tif (a < 0) x0 *= -1;",
			"\tif (b < 0) y0 *= -1;",
			"\treturn true;",
			"}",
			"void shift_solution(ll &x, ll &y, ll a, ll b, ll cnt) {",
			"\tx += cnt * b;",
			"\ty -= cnt * a;",
			"}",
			"// returns the number of solutions where x is in the range[minx, maxx] and y is in the range[miny, maxy]",
			"ll find_all_solutions(ll a, ll b, ll c, ll minx, ll maxx, ll miny,ll maxy) {",
			"\tll x, y, g;",
			"\tif (find_any_solution(a, b, c, x, y, g) == 0) return 0;",
			"\tif (a == 0 and b == 0) {",
			"\t\tassert(c == 0);",
			"\t\treturn 1LL * (maxx - minx + 1) * (maxy - miny + 1);",
			"\t}",
			"\tif (a == 0) {",
			"\t\treturn (maxx - minx + 1) * (miny <= c / b and c / b <= maxy);",
			"\t}  ",
			"\tif (b == 0) {",
			"\t\treturn (maxy - miny + 1) * (minx <= c / a and c / a <= maxx);",
			"\t}",
			"\ta /= g, b /= g;",
			"\tll sign_a = a > 0 ? +1 : -1;",
			"\tll sign_b = b > 0 ? +1 : -1;",
			"\tshift_solution(x, y, a, b, (minx - x) / b);",
			"\tif (x < minx) shift_solution(x, y, a, b, sign_b);",
			"\tif (x > maxx) return 0;",
			"\tll lx1 = x;",
			"\tshift_solution(x, y, a, b, (maxx - x) / b);",
			"\tif (x > maxx) shift_solution (x, y, a, b, -sign_b);",
			"\tll rx1 = x;",
			"\tshift_solution(x, y, a, b, -(miny - y) / a);",
			"\tif (y < miny) shift_solution (x, y, a, b, -sign_a);",
			"\tif (y > maxy) return 0;",
			"\tll lx2 = x;",
			"\tshift_solution(x, y, a, b, -(maxy - y) / a);",
			"\tif (y > maxy) shift_solution(x, y, a, b, sign_a);",
			"\tll rx2 = x;",
			"\tif (lx2 > rx2) swap (lx2, rx2);",
			"\tll lx = max(lx1, lx2);",
			"\tll rx = min(rx1, rx2);",
			"\tif (lx > rx) return 0;",
			"\treturn (rx - lx) / abs(b) + 1;",
			"}",
			"",
			"void solve(ll a, ll b, ll c, ll x1, ll x2, ll y1, ll y2) {",
			"\tll ans = find_all_solutions(a, b, c, x1, x2, y1, y2);",
			"",
			"}",
		],
		"description": ""
	},
	"tsp": {
		"prefix": "tsp",
		"body": [
			"ll tsp(vector<vector<ll>>& cost) {",
			"\tll n = (ll)cost.size();",
			"\tif (n <= 1) return n == 1 ? cost[0][0] : 0;",
			"",
			"\t// maximum cost to visit all cities",
			"\tconst ll INF = 1e18;",
			"\tll FULL = 1 << n, fullMask = FULL - 1;",
			"",
			"\tvector<vector<ll>> dp(FULL, vector<ll>(n, INF));",
			"\tdp[1][0] = 0;",
			"",
			"\tfor (ll mask = 1; mask < FULL; mask++) {",
			"\t\tfor (ll i = 0; i < n; i++) {",
			"",
			"\t\t\tif (!(mask & (1 << i))) continue;",
			"\t\t\tif (dp[mask][i] == INF) continue;",
			"",
			"\t\t\tfor (ll j = 0; j < n; j++) {",
			"\t\t\t\tif (!cost[i][j]) continue;",
			"\t\t\t\tif (mask & (1 << j)) continue;",
			"",
			"\t\t\t\tll nxt = mask | (1 << j);",
			"\t\t\t\tdp[nxt][j] = min(dp[nxt][j],  dp[mask][i] + cost[i][j]);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tll ans = INF;",
			"\tfor (ll i = 0; i < n; i++) {",
			"",
			"\t\tif (dp[fullMask][i] != INF && cost[i][0]) {",
			"\t\t\tans = min(ans, dp[fullMask][i] + cost[i][0]);",
			"\t\t}",
			"\t}",
			"",
			"\treturn ans;",
			"}",
		],
		"description": "Traveling Salesman Problem"
	},
	"Number of Solutions to a basic linear Algebraic Equation": {
		"prefix": "number of solutions to a basic linear algebraic equation",
		"body": [
			"const int N = 1e5 + 9, mod = 1e9 + 7;",
			"",
			"template <const int32_t MOD>",
			"struct modint {",
			"\tint32_t value;",
			"\tmodint() = default;",
			"\tmodint(int32_t value_) : value(value_) {}",
			"\tinline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }",
			"\tinline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }",
			"\tinline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }",
			"\tinline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }",
			"\tinline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }",
			"\tinline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }",
			"\tinline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }",
			"\tmodint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }",
			"\tmodint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime",
			"\tinline modint<MOD> operator /  (modint<MOD> other) const { return *this *  other.inv(); }",
			"\tinline modint<MOD> operator /= (modint<MOD> other)       { return *this *= other.inv(); }",
			"\tinline bool operator == (modint<MOD> other) const { return value == other.value; }",
			"\tinline bool operator != (modint<MOD> other) const { return value != other.value; }",
			"\tinline bool operator < (modint<MOD> other) const { return value < other.value; }",
			"\tinline bool operator > (modint<MOD> other) const { return value > other.value; }",
			"};",
			"template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD>(value) * n; }",
			"template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD>(value % MOD) * n; }",
			"template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.value; }",
			"template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.value; }",
			"",
			"using mint = modint<mod>;",
			"",
			"struct Combi{",
			"\tint n; vector<mint> facts, finvs, invs;",
			"\tCombi(int _n): n(_n), facts(_n), finvs(_n), invs(_n) {",
			"\t\tfacts[0] = finvs[0] = 1;",
			"\t\tinvs[1] = 1;",
			"\t\tfor (int i = 2; i < n; i++) invs[i] =  invs[mod % i] * (-mod / i);",
			"\t\tfor(int i = 1; i < n; i++){",
			"\t\t\tfacts[i] = facts[i - 1] * i;",
			"\t\t\tfinvs[i] = finvs[i - 1] * invs[i];",
			"\t\t}",
			"\t}",
			"\tinline mint fact(int n) { return facts[n]; }",
			"\tinline mint finv(int n) { return finvs[n]; }",
			"\tinline mint inv(int n) { return invs[n]; }",
			"\tinline mint ncr(int n, int k) { return n < k ? 0 : facts[n] * finvs[k] * finvs[n-k]; }",
			"};",
			"Combi C(N);",
			"",
			"// returns the number of solutions to the equation",
			"// x_1 + x_2 + ... + x_n = s and 0 <= l <= x_i <= r",
			"mint yo(int n, int s, int l, int r) { ",
			"\tif (s < l * n) return 0;",
			"\ts -= l * n;",
			"\tr -= l;",
			"\tmint ans = 0;",
			"\tfor (int k = 0; k <= n; k++) {",
        	"\t\tif (s - k - k * r + n - 1 + 1 < 0) break;",
			"\t\tmint cur = C.ncr(s - k - k * r + n - 1 + 1, n - 1 + 1) * C.ncr(n, k);",
			"\t\tif (k & 1) ans -= cur;",
			"\t\telse ans += cur;",
			"\t}",
			"\treturn ans;",
			"}",
		],
		"description": "Number of Solutions to a Linear Algebraic Eqiation",
	},
}