{
	// writer : kilogram
	// creating time : 2025-08-06
	
	"PS": {
		"prefix": "ps",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;\n",
			"typedef long long ll;\n",
			"int main()",
			"{",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(nullptr);\n",
			"\t$0",
			"\treturn 0;",
			"}",
		],
		"description": "Log output to console"
	},
	"DSU": {
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"\tvector<int> par, rnk, sz;",
			"\tint c;",
			"\tDSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {",
			"\t\tfor (int i = 1; i <= n; ++i) par[i] = i;",
			"\t}",
			"\tint find(int i) {",
			"\t\treturn (par[i] == i ? i : (par[i] = find(par[i])));",
			"\t}",
			"\tbool same(int i, int j) {",
			"\t\treturn find(i) == find(j);",
			"\t}",
			"\tint get_size(int i) {",
			"\t\treturn sz[find(i)];",
			"\t}",
			"\tint count() {",
			"\t\treturn c;",
			"\t}",
			"\tint unite(int i, int j) {",
			"\t\tif ((i = find(i)) == (j = find(j))) return -1;",
			"\t\telse --c;",
			"\t\tif (rnk[i] > rnk[j]) swap(i, j);",
			"\t\tpar[i] = j;",
			"\t\tsz[j] += sz[i];",
			"\t\tif (rnk[i] == rnk[j]) rnk[j]++;",
			"\t\treturn j;",
			"\t}",
			"};",
		],
		"description": "Disjoint Set union"
	},
	"Fenwick tree (BIT)": {
		"prefix": "fenwick",
		"body": [
			"template <class T>",
			"struct fenwick { //1-indexed",
			"\tint n; vector<T> t;",
			"\tfenwick() {}",
			"\tfenwick(int _n) {",
			"\t\tn = _n; t.assign(n + 1, 0);",
			"\t}",
			"\tT query(int i) {",
			"\t\tT ans = 0;",
			"\t\tfor (; i >= 1; i -= (i & -i)) ans += t[i];",
			"\t\treturn ans;",
			"\t}",
			"\tvoid upd(int i, T val) {",
			"\t\tif (i <= 0) return;",
			"\t\tfor (; i <= n; i += (i & -i)) t[i] += val;",
			"\t}",
			"\tvoid upd(int l, int r, T val) {",
			"\t\tupd(l, val);",
			"\t\tupd(r + 1, -val);",
			"\t}",
			"\tT query(int l, int r) {",
			"\t\treturn query(r) - query(l - 1);",
			"\t}",
			"};",
		],
		"description": "Fenwick tree = Binary indexed tree"
	},
	"Segment tree": {
		"prefix": "seg",
		"body": [
			"const int N = 3e5 + 9;",
			"",
			"int a[N];",
			"struct ST {",
			"\tint t[4 * N];",
			"\tstatic const int inf = 1e9;",
			"\tST() {",
			"\t\tmemset(t, 0, sizeof t);",
			"\t}",
			"\tvoid build(int n, int b, int e) {",
			"\t\tif (b == e) {",
			"\t\t\tt[n] = a[b];",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tbuild(l, b, mid);",
			"\t\tbuild(r, mid + 1, e);",
			"\t\tt[n] = max(t[l], t[r]);",
			"\t}",
			"\tvoid upd(int n, int b, int e, int i, int x) {",
			"\t\tif (b > i || e < i) return;",
			"\t\tif (b == e && b == i) {",
			"\t\t\tt[n] = x;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tupd(l, b, mid, i, x);",
			"\t\tupd(r, mid + 1, e, i, x);",
			"\t\tt[n] = max(t[l], t[r]);",
			"\t}",
			"\tint query(int n, int b, int e, int i, int j) {",
			"\t\tif (b > j || e < i) return -inf;",
			"\t\tif (b >= i && e <= j) return t[n];",
			"\t\tint mid = (b + e) >> 1, l = n << 1, r = l | 1;",
			"\t\tint L = query(l, b, mid, i, j);",
			"\t\tint R = query(r, mid + 1, e, i, j);",
			"\t\treturn max(L, R);",
			"\t}",
			"}t;",
		],
		"description": "Segment tree"
	},
	"Digit DP": {
		"prefix": "digit_dp",
		"body": [
			"vector<int> num;",
			"int a, b, d, k;",
			"int DP[12][12][2];",
			"",
			"int find(int pos, int cnt, int f) {",
			"\tif (cnt > k) return 0;",
			"",
			"\tif (pos == num.size()) {",
			"\t\tif (cnt == k) return 1;",
			"\t\treturn 0;",
			"\t}",
			"",
			"\tif (DP[pos][cnt][f] != -1) return DP[pos][cnt][f];",
			"\tint res = 0;",
			"",
			"\tint LMT;",
			"",
			"\t// f ? (greater than b) : (already smaller than b)",
			"\tif (f == 0) LMT = num[pos];",
			"\telse LMT = 9;",
			"",
			"\tfor (int dgt = 0; dgt <= LMT; dgt++) {",
			"\t\tint nf = f;",
			"\t\tint ncnt = cnt;",
			"\t\tif (f == 0 && dgt < LMT) nf = 1; /// The number is getting smaller at this position",
			"\t\tif (dgt == d) ncnt++;",
			"\t\tif (ncnt <= k) res += find(pos + 1, ncnt, nf);",
			"\t}",
			"",
			"\treturn DP[pos][cnt][f] = res;",
			"}",
			"",
			"int digitcount(int b) {",
			"\tnum.clear();",
			"\twhile(b > 0) {",
			"\t\tnum.push_back(b % 10);",
			"\t\tb /= 10;",
			"\t}",
			"\treverse(num.begin(), num.end());",
			"",
			"\tmemset(DP, -1, sizeof(DP));",
			"\tint res = find(0, 0, 0);",
			"\treturn res;",
			"}",
		],
		"description": "Digit DP"
	},
	"topological sorting": {
		"prefix": "topological_sorting",
		"body": [
			"const int N = 1e5 + 9;",
			"vector<int> g[N];",
			"bool vi[N];",
			"vector<int> ord;",
			"void dfs(int u) {",
			"\tvi[u] = true;",
			"\tfor (auto v : g[u]) {",
			"\t\tif (!vi[v]) {",
			"\t\t\tdfs(v);",
			"\t\t}",
			"\t}",
			"\tord.push_back(u);",
			"}",
			"",
			"void find(int n) {",
			"\tfor (int i = 1; i <= n; i++) {",
			"\t\tif (!vi[i]) {",
			"\t\t\tdfs(i);",
			"\t\t}",
			"\t}",
			"\treverse(ord.begin(), ord.end());",
			"",
			"\t// check is feasible",
			"\tvector<int> pos(n + 1);",
			"\tfor (int i = 0; i < (int) ord.size(); i++) {",
			"\t\tpos[ord[i]] = i;",
			"\t}",
			"\tfor (int u = 1; u <= n; u++) {",
			"\t\tfor (auto v : g[u]) {",
			"\t\t\t// We need to consider self loops too!",
			"\t\t\tif (pos[u] >= pos[v]) { ",
			"\t\t\t\t//print impossible",
			"\t\t\t\treturn;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\t// print the order",
			"\tfor (auto u : ord) cout << u << ' ';",
			"}",
		],
		"description": "topological sorting"
	},
	"DFS_tree": {
		"prefix": "dfs_tree",
		"body": [
			"const int N = 3e5 + 5;",
			"",
			"int bridge = 0;",
			"vector<int> adj[N];",
			"int lv[N];",
			"int dp[N];",
			"",
			"void dfs (int v) {",
			"\tdp[v] = 0;",
			"\tfor (int u : adj[v]) {",
			"\t\tif (lv[u] == 0) {",
			"\t\t\tlv[u] = lv[v] + 1;",
			"\t\t\tdfs(u);",
			"\t\t\tdp[v] += dp[u];",
			"\t\t} else if (lv[u] < lv[v]) {",
			"\t\t\tdp[v]++;",
			"\t\t} else if (lv[u] > lv[v]) {",
			"\t\t\tdp[v]--;",
			"\t\t}",
			"\t}",
			"",
			"\tdp[v]--;",
			"",
			"\tif (lv[v] > 1 && dp[v] == 0) {",
			"\t\tbridge++;",
			"\t}",
			"}",
		],
		"description": "classical dfs tree implementation"
	},
	"cycle detection": {
		"prefix": "cycle detection",
		"body": [
			"// It is possible both undigraph and digraph.",
			"const int N = 5e5 + 9;",
			"",
			"vector<pair<int, int>> g[N];",
			"int vis[N], par[N], e_id[N];",
			"vector<int> cycle; // simple cycle, contains edge ids",
			"",
			"bool dfs(int u) {",
			"\tif (!cycle.empty()) return 1;",
			"\tvis[u] = 1;",
			"\tfor (auto [v, id] : g[u]) {",
			"\t\tif (v != par[u]) {",
			"\t\t\tif (vis[v] == 0) {",
			"\t\t\t\tpar[v] = u;",
			"\t\t\t\te_id[v] = id;",
			"\t\t\t\tif (dfs(v)) return 1;",
			"\t\t\t}",
			"\t\t\telse if (vis[v] == 1) {",
			"\t\t\t\t// cycle here",
			"\t\t\t\tcycle.push_back(id);",
			"\t\t\t\tfor (int x = u; x != v; x = par[x]) {",
			"\t\t\t\t\tcycle.push_back(e_id[x]);",
			"\t\t\t\t}",
			"\t\t\t\treturn 1;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvis[u] = 2;",
			"\treturn 0;",
			"}",
			"void solve(int n, int m) {",
			"\tfor (int i = 1; i < m + 1; i++) {",
			"\t\tint u, v;",
			"\t\tcin >> u >> v;",
			"\t\tu++;",
			"\t\tv++;",
			"\t\tg[u].push_back({v, i});",
			"\t}",
			"\tfor (int u = 1; u < n + 1; u++) {",
			"\t\tif (vis[u] == 0 && dfs(u)) {",
			"\t\t\t// this graph is acyclic",
			"\t\t\tfor (auto x : cycle) {",
			"\t\t\t\t// any cycle",
			"\t\t\t}",
			"\t\t\treturn;",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "cycle detection"
	},
	"Binary Lifting and lowest common ancester": {
		"prefix": "lca",
		"body": [
			"const int N = 3e5 + 9, LG = 18;",
			"",
			"vector<int> g[N];",
			"int par[N][LG + 1], dep[N], sz[N];",
			"// don't forget to call dfs(1)",
			"void dfs(int u, int p = 0) {",
			"\tpar[u][0] = p;",
			"\tdep[u] = dep[p] + 1;",
			"\tsz[u] = 1;",
			"\tfor (int i = 1; i <= LG; i++) par[u][i] = par[par[u][i - 1]][i - 1];",
			"\tfor (auto v : g[u]) {",
			"\t\tif (v != p) {",
			"\t\t\tdfs(v, u);",
			"\t\t\tsz[u] += sz[v];",
			"\t\t}",
			"\t}",
			"}",
			"int lca(int u, int v) {",
			"\tif (dep[u] < dep[v]) swap(u, v);",
			"\tfor (int k = LG; k >= 0; k--) if (dep[par[u][k]] >= dep[v]) u = par[u][k];",
			"\tif (u == v) return u;",
			"\tfor (int k = LG; k >= 0; k--) if (par[u][k] != par[v][k]) u = par[u][k], v = par[v][k];",
			"\treturn par[u][0];",
			"}",
			"// 'kth'function is a Binary Lifting",
			"int kth(int u, int k) {",
			"\tassert(k >= 0);",
			"\tfor (int i = 0; i <= LG; i++) if (k & (1 << i)) u = par[u][i];",
			"\treturn u;",
			"}",
			"int dist(int u, int v) {",
			"\tint l = lca(u, v);",
			"\treturn dep[u] + dep[v] - (dep[l] << 1);",
			"}",
			"//kth node from u to v, 0th node is u",
			"int go(int u, int v, int k) {",
			"\tint l = lca(u, v);",
			"\tint d = dep[u] + dep[v] - (dep[l] << 1);",
			"\tassert(k <= d);",
			"\tif (dep[l] + k <= dep[u]) return kth(u, k);",
			"\tk -= dep[u] - dep[l];",
			"\treturn kth(v, dep[v] - dep[l] - k);",
			"}",
		],
		"description": "Binary Lifting and lowest common ancester"
	},
	"SCC": {
		"prefix": "scc",
		"body": [
			"const int N = 3e5 + 9;",
			"",
			"// given a directed graph return the minimum number of edges to be added so that the whole graph become an SCC",
			"// you need to restore original graph in g and reverse graph in r.",
			"bool vis[N];",
			"vector<int> g[N], r[N], G[N], vec; //G is the condensed graph",
			"void dfs1(int u) {",
			"\tvis[u] = 1;",
			"\tfor(auto v : g[u]) if (!vis[v]) dfs1(v);",
			"\tvec.push_back(u);",
			"}",
			"",
			"vector<int> comp;",
			"void dfs2(int u) {",
			"\tcomp.push_back(u);",
			"\tvis[u] = 1;",
			"\tfor(auto v : r[u]) if (!vis[v]) dfs2(v);",
			"}",
			"",
			"int idx[N], in[N], out[N];",
			"",
			"void find(int n) {",
			"\tfor(int i = 1; i <= n; i++) if(!vis[i]) dfs1(i);",
			"\treverse(vec.begin(), vec.end());",
			"\tmemset(vis, 0, sizeof(vis));",
			"\tint scc = 0;",
			"\tfor(auto u : vec) {",
			"\t\tif(!vis[u]) {",
			"\t\t\tcomp.clear();",
			"\t\t\tdfs2(u);",
			"\t\t\tscc++;",
			"\t\t\tfor(auto x : comp) idx[x] = scc;",
			"\t\t}",
			"\t}",
			"\tfor(int u = 1; u <= n; u++) {",
			"\t\tfor(auto v : g[u]) {",
			"\t\t\tif(idx[u] != idx[v]) {",
			"\t\t\t\tin[idx[v]]++, out[idx[u]]++;",
			"\t\t\t\tG[idx[u]].push_back(idx[v]);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tint needed_in = 0, needed_out = 0;",
			"\tfor(int i = 1; i <= scc; i++) {",
			"\t\tif(!in[i]) needed_in++;",
			"\t\tif(!out[i]) needed_out++;",
			"\t}",
			"\tint ans = max(needed_in, needed_out);",
			"\tif(scc == 1) ans = 0;",
			"\tcout << ans;",
			"}",
		],
		"description": "SCC"
	},
	"Articulation Bridges and Bridge Tree": {
		"prefix": "bridge tree",
		"body": [
			"// you should write TECC t(g) int main funtion after that you add edges in graph g.",
			"struct TECC { // 0 indexed",
			"\tint n, k;",
			"\tvector<vector<int>> g, t;",
			"\tvector<bool> used;",
			"\tvector<int> comp, ord, low;",
			"\tusing edge = pair<int, int>;",
			"\tvector<edge> br;",
			"\tvoid dfs(int x, int prv, int &c) {",
			"\t\tused[x] = 1; ord[x] = c++; low[x] = n;",
			"\t\tbool mul = 0;",
			"\t\tfor (auto y : g[x]) {",
			"\t\t\tif (used[y]) {",
			"\t\t\t\tif (y != prv || mul) low[x] = min(low[x], ord[y]);",
			"\t\t\t\telse mul = 1;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tdfs(y, x, c);",
			"\t\t\tlow[x] = min(low[x], low[y]);",
			"\t\t}",
			"\t}",
			"\tvoid dfs2(int x, int num) {",
			"\t\tcomp[x] = num;",
			"\t\tfor (auto y : g[x]) {",
			"\t\t\tif (comp[y] != -1) continue;",
			"\t\t\tif (ord[x] < low[y]) {",
			"\t\t\t\tbr.push_back({x, y});",
			"\t\t\t\tk++;",
			"\t\t\t\tdfs2(y, k);",
			"\t\t\t} else dfs2(y, num);",
			"\t\t}",
			"\t}",
			"\tTECC(const vector<vector<int>> &g): g(g), n(g.size()), used(n), comp(n, -1), ord(n), low(n), k(0) {",
			"\t\tint c = 0;",
			"\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\tif (used[i]) continue;",
			"\t\t\tdfs(i, -1, c);",
			"\t\t\tdfs2(i, k);",
			"\t\t\tk++;",
			"\t\t}",
			"\t}",
			"\t// build bridges tree",
			"\tvoid build_tree() {",
			"\t\tt.resize(k);",
			"\t\tfor (auto e : br) {",
			"\t\t\tint x = comp[e.first], y = comp[e.second];",
			"\t\t\tt[x].push_back(y);",
			"\t\t\tt[y].push_back(x);",
			"\t\t}",
			"\t}",
			"};",
			"void solve(int n, int m) {",
			"\tvector<vector<int>> g(n);",
			"\tfor (int i = 0; i < m; i++) {",
			"\t\tint a, b; cin >> a >> b;",
			"\t\tg[a].push_back(b);",
			"\t\tg[b].push_back(a);",
			"\t}",
			"\tTECC t(g);",
			"\tvector<vector<int>> ans(t.k);",
			"\tfor (int i = 0; i < n; i++) {",
			"\t\tans[t.comp[i]].push_back(i);",
			"\t}",
			"",
			"\tcout << ans.size() << '\\n';",
			"\tfor (auto x : ans) {",
			"\t\tcout << x.size();",
			"\t\tfor (auto y : x) cout << ' ' << y;",
			"\t\tcout << '\\n';",
			"\t}",
			"}",
		],
		"description": "Articulation Bridges and Bridge Tree"
	},
	"Articulation Points": {
		"prefix": "articulation points",
		"body": [
			"const int N = 3e5 + 9;",
			"",
			"// art = check an Articulation point.",
			"// low = maybe restore parent? and update parent of the current node to min(low[u], low[v])",
			"// dis = check whether a current vertex is visited or not.",
			"int T, low[N], dis[N], art[N];",
			"vector<int> g[N];",
			"void dfs(int u, int pre = 0) {",
			"\tlow[u] = dis[u] = ++T;",
			"\tint child = 0;",
			"\tfor(auto v : g[u]) {",
			"\t\tif(!dis[v]) {",
			"\t\t\tdfs(v, u);",
			"\t\t\tlow[u] = min(low[u], low[v]);",
			"\t\t\tif(low[v] >= dis[u] && pre != 0) art[u] = 1;",
			"\t\t\t++child;",
			"\t\t}",
			"\t\telse if(v != pre) low[u] = min(low[u], dis[v]);",
			"\t}",
			"\tif(pre == 0 && child > 1) art[u] = 1;",
			"}",
		],
		"description": "Articulation Points"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"const int N = 3e5 + 9, mod = 998244353;",
			"",
			"// you can delete 'cnt' vector if you don't need that",
			"int n, m;",
			"vector<pair<int, int>> g[N], r[N];",
			"vector<long long> dijkstra(int s, int t, vector<int> &cnt) {",
			"\tconst long long inf = 1e18;",
			"\tpriority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> q;",
			"\tvector<long long> d(n + 1, inf);",
			"\tvector<bool> vis(n + 1, 0);",
			"\tq.push({0, s});",
			"\td[s] = 0;",
			"\tcnt.resize(n + 1, 0); // number of shortest paths",
			"\tcnt[s] = 1;",
			"\twhile(!q.empty()) {",
			"\t\tauto x = q.top();",
			"\t\tq.pop();",
			"\t\tint u = x.second;",
			"\t\tif(vis[u]) continue;",
			"\t\tvis[u] = 1;",
			"\t\tfor(auto y: g[u]) {",
			"\t\t\tint v = y.first;",
			"\t\t\tlong long w = y.second;",
			"\t\t\tif(d[u] + w < d[v]) {",
			"\t\t\t\td[v] = d[u] + w;",
			"\t\t\t\tq.push({d[v], v});",
			"\t\t\t\tcnt[v] = cnt[u];",
			"\t\t\t} else if(d[u] + w == d[v]) cnt[v] = (cnt[v] + cnt[u]) % mod;",
			"\t\t}",
			"\t}",
			"\treturn d;",
			"}",
			"",
			"int u[N], v[N], w[N];",
			"",
			"void solve(int n, int m, int s, int t) {",
			"\tfor(int i = 1; i <= m; i++) {",
			"\t\tcin >> u[i] >> v[i] >> w[i];",
			"\t\tg[u[i]].push_back({v[i], w[i]});",
			"\t\tr[v[i]].push_back({u[i], w[i]});",
			"\t}",
			"\tvector<int> cnt1, cnt2;",
			"\tauto d1 = dijkstra(s, t, cnt1);",
			"\tauto d2 = dijkstra(t, s, cnt2);",
			"\t",
			"\tlong long ans = d1[t];",
			"\tfor(int i = 1; i <= m; i++) {",
			"\t\tint x = u[i], y = v[i];",
			"\t\tlong long nw = d1[x] + w[i] + d2[y];",
			"\t\tif(nw == ans && 1LL * cnt1[x] * cnt2[y] % mod == cnt1[t]) //YES",
			"\t\telse if(nw - ans + 1 < w[i]) // print nw - ans + 1",
			"\t\telse // No",
			"\t}",
			"}",
		],
		"description": "dijkstra implementation"
	},
	"Minimum & Maximum Spanning Tree": {
		"prefix": "mst",
		"body": [
			"struct DSU {",
			"\tvector<int> par, rnk, sz;",
			"\tint c;",
			"\tDSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {",
			"\t\tfor (int i = 1; i <= n; ++i) par[i] = i;",
			"\t}",
			"\tint find(int i) {",
			"\t\treturn (par[i] == i ? i : (par[i] = find(par[i])));",
			"\t}",
			"\tbool same(int i, int j) {",
			"\t\treturn find(i) == find(j);",
			"\t}",
			"\tint get_size(int i) {",
			"\t\treturn sz[find(i)];",
			"\t}",
			"\tint count() {",
			"\t\treturn c;",
			"\t}",
			"\tint unite(int i, int j) {",
			"\t\tif ((i = find(i)) == (j = find(j))) return -1;",
			"\t\telse --c;",
			"\t\tif (rnk[i] > rnk[j]) swap(i, j);",
			"\t\tpar[i] = j;",
			"\t\tsz[j] += sz[i];",
			"\t\tif (rnk[i] == rnk[j]) rnk[j]++;",
			"\t\treturn j;",
			"\t}",
			"};",
			"",
			"void mst(int n, int m) {",
			"\tvector<array<int, 3>> ed;",
			"\tfor (int i = 1; i < m + 1; i++) {",
			"\t\tint u, v, w;",
			"\t\tcin >> u >> v >> w;",
			"\t\ted.push_back({w, u, v});",
			"\t}",
			"\t// if you want to find Maximum Spanning Tree,",
			"\t// then you should sort all edge of graph ",
			"\t// in decreasing order of weights.",
			"\tsort(ed.begin(), ed.end());",
			"\tll ans = 0;",
			"\tDSU d(n);",
			"\tfor (auto e : ed) {",
			"\t\tint u = e[1], v = e[2], w = e[0];",
			"\t\tif (d.same(u, v)) continue;",
			"\t\tans += w;",
			"\t\td.unite(u, v);",
			"\t}",
			"\t//print ans",
			"}",
		],
		"description": "Minimum & Maximum Spanning Tree"
	},
	"2-SAT": {
		"prefix": "2sat",
		"body": [
			"/*",
			"zero Indexed",
			"we have vars variables",
			"F=(x_0 XXX y_0) and (x_1 XXX y_1) and ... (x_{vars-1} XXX y_{vars-1})",
			"here {x_i,y_i} are variables",
			"and XXX belongs to {OR,XOR}",
			"is there any assignment of variables such that F=true",
			"*/",
			"struct twosat {",
			"\tint n;  // total size combining +, -. must be even.",
			"\tvector<vector<int>> g, gt;",
			"\tvector<bool> vis, res;",
			"\tvector<int> comp;",
			"\tstack<int> ts;",
			"\ttwosat(int vars = 0) {",
			"\t\tn = vars << 1;",
			"\t\tg.resize(n);",
			"\t\tgt.resize(n);",
			"\t}",
			"",
			"\t//zero indexed, be careful",
			"\t//if you want to force variable a to be true in OR or XOR combination",
			"\t//add addOR (a,1,a,1);",
			"\t//if you want to force variable a to be false in OR or XOR combination",
			"\t//add addOR (a,0,a,0);",
			"",
			"\t//(x_a or (not x_b))-> af=1,bf=0",
			"\tvoid addOR(int a, bool af, int b, bool bf) {",
			"\t\ta += a + (af ^ 1);",
			"\t\tb += b + (bf ^ 1);",
			"\t\tg[a ^ 1].push_back(b);  // !a => b",
			"\t\tg[b ^ 1].push_back(a);  // !b => a",
			"\t\tgt[b].push_back(a ^ 1);",
			"\t\tgt[a].push_back(b ^ 1);",
			"\t}",
			"\t//(!x_a xor !x_b)-> af=0, bf=0",
			"\tvoid addXOR(int a, bool af, int b, bool bf) {",
			"\t\taddOR(a, af, b, bf);",
			"\t\taddOR(a, !af, b, !bf);",
			"\t}",
			"\tvoid _add(int a,bool af,int b,bool bf) {",
			"\t\ta += a + (af ^ 1);",
			"\t\tb += b + (bf ^ 1);",
			"\t\tg[a].push_back(b);",
			"\t\tgt[b].push_back(a);",
			"\t}",
			"\t//add this type of condition->",
			"\t//add(a,af,b,bf) means if a is af then b must need to be bf",
			"\tvoid add(int a,bool af,int b,bool bf) {",
			"\t\t_add(a, af, b, bf);",
			"\t\t_add(b, !bf, a, !af);",
			"\t}",
			"\tvoid dfs1(int u) {",
			"\t\tvis[u] = true;",
			"\t\tfor(int v : g[u]) if(!vis[v]) dfs1(v);",
			"\t\tts.push(u);",
			"\t}",
			"\tvoid dfs2(int u, int c) {",
			"\t\tcomp[u] = c;",
			"\t\tfor(int v : gt[u]) if(comp[v] == -1) dfs2(v, c);",
			"\t}",
			"\tbool ok() {",
			"\t\tvis.resize(n, false);",
			"\t\tfor(int i = 0; i < n; ++i) if(!vis[i]) dfs1(i);",
			"\t\tint scc = 0;",
			"\t\tcomp.resize(n, -1);",
			"\t\twhile(!ts.empty()) {",
			"\t\t\tint u = ts.top();",
			"\t\t\tts.pop();",
			"\t\t\tif(comp[u] == -1) dfs2(u, scc++);",
			"\t\t}",
			"\t\tres.resize(n / 2);",
			"\t\tfor(int i = 0; i < n; i += 2) {",
			"\t\t\tif(comp[i] == comp[i + 1]) return false;",
			"\t\t\tres[i / 2] = (comp[i] > comp[i + 1]);",
			"\t\t}",
			"\t\treturn true;",
			"\t}",
			"};",
			"void solve(int n, int m) {",
			"\ttwosat ts(n);",
			"\tfor(int i = 0; i < m; i++){",
			"\t\tint u, v, k; cin >> u >> v >> k;",
			"\t\t--u; --v;",
			"\t\tif(k) ts.add(u, 0, v, 0), ts.add(u, 1, v, 1), ts.add(v, 0, u, 0), ts.add(v, 1, u, 1);",
			"\t\telse ts.add(u, 0, v, 1), ts.add(u, 1, v, 0), ts.add(v, 0, u, 1), ts.add(v, 1, u, 0);",
			"\t}",
			"\tint k = ts.ok();",
			"\tif(!k) {",
			"\t\t// impossible",
			"\t} else {",
			"\t\tvector<int> v;",
			"\t\tfor(int i = 0; i < n; i++) if(ts.res[i]) v.push_back(i);",
			"\t\t// v size, element in v.",
			"\t}",
			"}",
		],
		"description": "2-SAT"
	},
}